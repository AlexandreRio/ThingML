/**
 * Copyright (C) 2011 SINTEF <franck.fleurey@sintef.no>
 *
 * Licensed under the GNU LESSER GENERAL PUBLIC LICENSE, Version 3, 29 June 2007;
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * @author Brice MORIN, SINTEF IKT
 */
package org.thingml.utils.comm

import ch.eth.coap.endpoint.{Resource, RemoteResource, LocalResource}
import org.thingml.utils.log.Logger
import ch.eth.coap.coap.{Request, PUTRequest, Response, CodeRegistry, POSTRequest, GETRequest, ResponseHandler}

class ThingMLCoAPRequest(val code : Byte, val resourceURI : String = "ThingML", val serverURI : String) extends ResponseHandler {

  def sendData(bytes : Array[Byte]) {
    Logger.debug("sendData(" + bytes.mkString("[", ", ", "]") + ")")
    val request = new PUTRequest()
    request.setURI(serverURI + "/" + resourceURI)
    request.setPayload(bytes)

    request.enableResponseQueue(false)//Asynchronous response
    request.registerResponseHandler(this)    
    request.execute()
  }
  
  override def handleResponse(response : Response) {
    Logger.debug("handleResponse: " + response)
    Logger.info("Response RTT = " + response.getRTT)
    response.log();
  }  
}

trait ThingMLCoAPResource {
  self : Resource =>
  
  val code : Byte = self match {
    case l : ThingMLCoAPLocalResource => l.code
    case r : ThingMLCoAPRemoteResource => r.code
  }
  
  val server : CoAP = self match {
    case l : ThingMLCoAPLocalResource => l.server
    case r : ThingMLCoAPRemoteResource => r.server
  }
  
  setResourceTitle("Generic ThingML Resource")
  setResourceType("ThingMLResource")

  val buffer = new Array[Byte](18)
  
  val statusBuffer = new StringBuilder()

  def isThingML(payload : Array[Byte]) : Boolean = {
    payload.size == 18 && payload(4) == code && payload(0) == 0x12 && payload(17) == 0x13
  }

  def resetBuffer(){
    for(i <- 0 until 18) {
      buffer(i) = 0x13
    }
  }

  //TODO: we should support more standard serialization like JSON
  def parse(payload : String) : Option[Array[Byte]] = {
    Logger.debug("parse " + payload)
    try {
      var params = Map[String,  String]()
      payload.split(",").collect{case p => p.trim()}.foreach{p =>
        val param = p.split(":")
        if (param.size == 2) {
          params += (param(0).trim() -> param(1).trim())
        }
      }
      Logger.debug("  " + params.size + " param(s)")
      if (checkParams(params)) {
        Logger.info("payload has right number of parameters and will be parsed.")
        doParse(params)
        return Option(buffer)
      } else {
        statusBuffer append "Payload has NOT the right number of parameters or CANNOT be parsed. "
        Logger.warning("payload has NOT the right number of parameters or CANNOT be parsed.")
        return None
      }
    } catch {
      case e : Exception =>
        statusBuffer append "Payload CANNOT be parsed. "
        Logger.error("payload CANNOT be parsed.")
        Logger.error(e.getMessage)
        e.printStackTrace()
        return None
    }
  }
  def doParse(params : Map[String, String]) {} //This should be overridden in message resource generated by ThingML
  def checkParams(params : Map[String, String]) = true//This should be overridden in message resource generated by ThingML to check the number and types of params
  def setAttributes() {} //set the attribute of the CoAP resource from a serialized ThingML message
  
  
  //PUT is the only method supported (currently) by ThingML resources
  override def performPUT(request: PUTRequest) {
    statusBuffer.clear
    Logger.debug("performPUT: " + request.getPayload.mkString ("[", ", ", "]"))
    
    val response = new Response(CodeRegistry.RESP_CONTENT)

    //Send the payload to the ThingML side
    if (isThingML(request.getPayload)) {
      Array.copy(request.getPayload, 0, buffer, 0, buffer.size)
      setAttributes
      server.coapThingML.receive(request.getPayload)
      Logger.info("PUT request can be handled: " + request)
      response.setPayload("OK!")
    } else {
      parse(request.getPayloadString) match {
        case Some(p) =>
          server.coapThingML.receive(p)
          setAttributes
          Logger.info("PUT request can be handled: " + request)
          response.setPayload("OK!")
        case None => 
          Logger.warning("PUT request cannot be handled: " + request + " Reason: " + statusBuffer.toString)
          response.setPayload("Request cannot be handled. Reason: " + statusBuffer.toString)
      }
    }

    //Default response, whatever we do with the request
    
    
    request.respond(response)
  }

  override def performPOST(request: POSTRequest) {
    statusBuffer.clear
    Logger.debug("performPOST: " + request.getPayload.mkString ("[", ", ", "]"))
    Logger.warning("POST not supported")

    //Default response, whatever we do with the request
    val response = new Response(CodeRegistry.RESP_METHOD_NOT_ALLOWED)
    response.setPayload("POST not supported by ThingML resources. Please use PUT")
    request.respond(response)
  }

  override def performGET(request: GETRequest) {
    statusBuffer.clear
    Logger.debug("performGET: " + request.getPayload.mkString ("[", ", ", "]"))
    
    val builder = new java.lang.StringBuilder()
    writeAttributes(builder)
    
    //Default response, whatever we do with the request
    val response = new Response(CodeRegistry.RESP_CONTENT)
    response.setPayload(builder.toString)
    request.respond(response)
  }
}

class ThingMLCoAPLocalResource(val resourceIdentifier : String = "ThingML", override val code : Byte = 0x00, override val server : CoAP) extends LocalResource(resourceIdentifier) with ThingMLCoAPResource{
  def addSubResource(resource : ThingMLCoAPLocalResource) {
    super.addSubResource(resource)
    server.resourceMap += (resource.code -> resource.getResourcePath)
  }
}

class ThingMLCoAPRemoteResource(val resourceIdentifier : String = "ThingML", override val code : Byte = 0x00, override val server : CoAP) extends RemoteResource with ThingMLCoAPResource{
  setResourceIdentifier(resourceIdentifier)
  
  def addSubResource(resource : ThingMLCoAPLocalResource) {
    super.addSubResource(resource)
    server.resourceMap += (resource.code -> resource.getResourcePath)
  }
}