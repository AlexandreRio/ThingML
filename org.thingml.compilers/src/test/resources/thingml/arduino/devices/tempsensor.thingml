import "../core/arduino.thingml"
import "softtimer.thingml"

thing fragment TempSensorMsgs {
	
	message temperature(t : Int16, min : Int16, max : Int16);
	message get_temperature();
	message reset_min_max();
	
	message subscribe_temperature(interval : Int16); // in seconds if the sampling rate is 1 sec
	message unsubscribe_temperature();
	
	message activate_alarms(low : Int16, high : Int16);
	message high_temp_alarm(t : Int16);
	message low_temp_alarm(t : Int16);
	message deactivate_alarms();
}

thing TempSensor includes TempSensorMsgs, ThingMLScheduler, ArduinoStdlibMsgs, TimerMsgs
{	

	readonly property pin : AnalogPin = AnalogPin:A_0
	readonly property sample_rate : Int16 = 1000 // should be 1 sec
	
    property temp : Int16
    property min : Int16
    property max : Int16
    
    property interval : Int16
    
    property min_alarm : Int16
    property max_alarm : Int16
	
	provided port tempsensor {
		receives get_temperature, reset_min_max, subscribe_temperature, unsubscribe_temperature
		sends temperature
	}
	
	provided port tempalarms {
		receives activate_alarms, deactivate_alarms
		sends low_temp_alarm, high_temp_alarm
	}
	
	required port adc
    {
        sends analogRead
		receives analogReadResult    
    }
	
	required port timer {
		sends timer_start
		receives timer_timeout
	}
	
	required port polling {
		receives poll
	}
	
	 statechart TempSensorImpl init Idle {
        
        internal event tempsensor?get_temperature
        action tempsensor!temperature(temp, min, max)
        
        internal event tempsensor?reset_min_max
        action do
        	min = temp
        	max = temp
        end
        
        state Idle {
   			on entry timer!timer_start(sample_rate)
   			
   			transition -> Sampling
   			event timer?timer_timeout
        }
        
        state Sampling {
        
        	on entry adc!analogRead(pin)
        	
        	transition -> Idle
    		event m : adc?analogReadResult
    		action do
    			// average with the last 3 samples
    			temp = (m.value + 3 * temp) / 4 
    			if (temp < min) min = temp
    			if (temp > max) max = temp
    		end
        }
        
        region Subscription init NoSubscription {
        	
        	state NoSubscription {
        		transition -> HasSubscription
        		event m : tempsensor?subscribe_temperature
        		action interval = m.interval
        	}
        	
        	state HasSubscription {
        	
        		property counter : Int16
        		
        		on entry counter = interval
        		
        		internal event timer?timer_timeout
        		guard counter > 0
        		action counter = counter - 1
        		
        		transition -> HasSubscription
        		event timer?timer_timeout
        		guard counter == 0
        		after tempsensor!temperature(temp, min, max)
        		
        		transition -> NoSubscription
        		event tempsensor?unsubscribe_temperature
        		
        	}
        	
        }
        
        region Alarm init Disactivated {
        	
        	state Disactivated {
        		transition -> Activated
        		event m : tempalarms?activate_alarms
        		action do
        			min_alarm = m.low
        			max_alarm = m.high
        		end
        	}
        	
        	composite state Activated  init NoAlarm {
        	
        		state NoAlarm {
        			
        			transition -> HighTempAlarm
        			event polling?poll
        			guard temp > max_alarm
        			
        			transition -> LowTempAlarm
        			event polling?poll
        			guard temp < min_alarm
        			
        		}
        		
        		state HighTempAlarm {
        			
        			on entry tempalarms!high_temp_alarm(temp)
        			
        			transition -> NoAlarm
        			event polling?poll
        			guard temp < max_alarm
        		}
        		
        		state LowTempAlarm {
        			on entry tempalarms!low_temp_alarm(temp)
        			
        			transition -> NoAlarm
        			event polling?poll
        			guard temp > min_alarm
        		}
        		
        		transition -> Disactivated
        		event tempalarms?deactivate_alarms
        		
        	}
        	
        }
    }
}