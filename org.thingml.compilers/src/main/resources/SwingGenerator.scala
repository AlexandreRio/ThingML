/**
 * Copyright (C) 2011 SINTEF <franck.fleurey@sintef.no>
 *
 * Licensed under the GNU LESSER GENERAL PUBLIC LICENSE, Version 3, 29 June 2007;
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This code generator targets the SMAc Framework
 * see https://github.com/brice-morin/SMAc
 * @author: Brice MORIN <brice.morin@sintef.no>
 */
package org.thingml.javagenerator.gui

import org.sintef.thingml.constraints.ThingMLHelpers
import org.thingml.model.scalaimpl.ThingMLScalaImpl._
import org.sintef.thingml.resource.thingml.analysis.helper.CharacterEscaper
import scala.collection.JavaConversions._
import java.util.{ArrayList, Hashtable}
import org.sintef.thingml._

object Context {
  val builder = new StringBuilder()
  
  var thing : Thing = _
  var pack : String = _
  var isMirror = false
  
  val debug = false
  
  //TODO: should be replaced by Java keywords
  val keywords = scala.List("implicit","match","requires","type","var","abstract","do","finally","import","object","throw","val","case","else","for","lazy","override","return","trait","catch","extends","forSome","match","package","sealed","try","while","class","false","if","new","private","super","true","with","def","final","implicit","null","protected","this","yield","_",":","=","=>","<-","<:","<%",">:","#","@")
  def protectJavaKeyword(value : String) : String = {
    if(keywords.exists(p => p.equals(value))){
      return "`"+value+"`"
    } 
    else {
      return value
    }
  }

  def firstToUpper(value : String) : String = {
    var result = ""
    if (value.size > 0)
      result += value(0).toUpperCase 
    if (value.size > 1)
      result += value.substring(1, value.length)
    return result
  }
  
  def init {
    builder.clear
    thing = null
    pack = null
  }
}

object SwingGenerator {
  implicit def scalaGeneratorAspect(self: Thing): ThingScalaGenerator = ThingScalaGenerator(self)
  implicit def scalaGeneratorAspect(self: Configuration): ConfigurationScalaGenerator = ConfigurationScalaGenerator(self)
  implicit def scalaGeneratorAspect(self: Instance): InstanceScalaGenerator = InstanceScalaGenerator(self)
  
  def compileAllJava(model: ThingMLModel, pack : String): Hashtable[Configuration, String] = {
    val result = new Hashtable[Configuration, String]()
    compileAll(model, pack).foreach{entry =>
      result.put(entry._1, entry._2)
    }
    result
  }
  
  def compileAll(model: ThingMLModel, pack : String): Map[Configuration, String] = {
    Context.init
    Context.pack = pack
    generateHeader()
    
    var result = Map[Configuration, String]()
    model.allConfigurations.filter{c=> !c.isFragment}.foreach {
      t => result += (t -> compile(t, pack))
    }
    result
  }
  
  def compile(t: Configuration, pack : String) = {
    t.generateScala()
    Context.builder.toString
  }
  
  def generateHeader(builder: StringBuilder = Context.builder) = {
    builder append "/**\n"
    builder append " * File generated by the ThingML IDE\n"
    builder append " * /!\\Do not edit this file/!\\\n"
    builder append " * In case of a bug in the generated code,\n"
    builder append " * please submit an issue on our GitHub\n"
    builder append " **/\n\n"

    builder append "package " + Context.pack + "\n"
    builder append "import org.sintef.smac.*;\n"
    builder append "import org.thingml.devices.*;\n"
    
    builder append "import java.awt.Color;\n"
    builder append "import java.awt.Dimension;\n"
    builder append "import java.awt.GridBagConstraints;\n"
    builder append "import java.awt.GridBagLayout;\n"
    builder append "import java.awt.Insets;\n"
    builder append "import java.awt.event.ActionEvent;\n"
    builder append "import java.awt.event.ActionListener;\n"
    builder append "import java.util.Random;\n"

    builder append "import javax.swing.JButton;\n"
    builder append "import javax.swing.JComboBox;\n"
    builder append "import javax.swing.JFrame;\n"
    builder append "import javax.swing.JLabel;\n"
    builder append "import javax.swing.JPanel;\n"
    builder append "import javax.swing.JScrollPane;\n"
    builder append "import javax.swing.JTextField;\n"
    builder append "import javax.swing.JTextPane;\n"
    builder append "import javax.swing.text.BadLocationException;\n"
    builder append "import javax.swing.text.Style;\n"
    builder append "import javax.swing.text.StyleConstants;\n"
    builder append "import javax.swing.text.StyleContext;\n"
    builder append "import javax.swing.text.StyledDocument;\n"    
  }
}

case class ThingMLScalaGenerator(self: ThingMLElement) {
  def generateScala(builder: StringBuilder = Context.builder) {
    // Implemented in the sub-classes
  }
}


case class ConfigurationScalaGenerator(override val self: Configuration) extends ThingMLScalaGenerator(self) {

  override def generateScala(builder: StringBuilder = Context.builder) {
    
    self.allThings.foreach { thing =>
      thing.generateScala()
    }
    
    generateJavaMain()
  }

  def generateJavaMain(builder: StringBuilder = Context.builder) {
  }
}

case class InstanceScalaGenerator(override val self: Instance) extends ThingMLScalaGenerator(self) {
  val instanceName = self.getType.getName + "_" + self.getName
}

case class ConnectorScalaGenerator(override val self: Connector) extends ThingMLScalaGenerator(self) {
  val instanceName = "c_" + (if (self.getName != null) self.getName + "_" else "") + self.hashCode 
  val clientName = self.getCli.getInstance.instanceName
  val serverName = self.getSrv.getInstance.instanceName
}


case class ThingScalaGenerator(override val self: Thing) extends ThingMLScalaGenerator(self) {

  override def generateSwing(builder: StringBuilder = Context.builder) {
     
    buffer append "public class Interactive" + self.getName + "DataGUI" + (if (!Context.isMirror) "Mirror" else "") + "implements ActionListener {\n"
	
	
    buffer append "private JTabbedPane tabbedPane = new JTabbedPane();\n"
    buffer append "private JFrame frame;\n"
    buffer append "private JTextPane screen;\n"
    buffer append "private JButton clearButton;\n"
	
    
    val messagesToSend = Pair(List[Message], List[Message]) = (if (!Context.isMirror) self.getPort.collect{p => p.sends} else self.getPort.collect{p => p.receives})
    val messagesToReceive = Pair(List[Message], List[Message]) = (if (!Context.isMirror) self.getPort.collect{p => p.receives} else self.getPort.collect{p => p.sends})

    messagesToSend.foreach{send =>
      send.generateSwing()
    }
    
    buffer append "}\n"
      
  }
}