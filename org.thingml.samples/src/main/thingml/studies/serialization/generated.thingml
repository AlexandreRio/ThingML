import "../../core/_scala/serializer.thingml"
import "../../core/serializer.thingml"

//test messages
thing fragment testMsgs {
    message m4(i : Integer, s : String);
    message m2(i : Integer);
    message m1();
    message m3(s : String);
}

//test thing
thing TestThing includes testMsgs
@mock "true"
{
    required port out {
       sends m1, m2, m3, m4
    }
    
    provided port in {
       receives m1, m2, m3, m4
    }        
}

//All the code below is generated
thing fragment RemoteMsgs includes testMsgs{
//message m1();//code=27
//message m2(i : Integer);//code=1
//message m3(s : String);//code=2
//message m4(i : Integer, s : String);//code=12
}

thing MessageSerializer includes DataTypeSerializerScala, Network, RemoteMsgs {
provided port out{
receives m1, m2, m3, m4
}

required port network {
sends packet
}

statechart SerializerBehavior init Serialize {
state Serialize{
internal event m : out?m1 action
do
var buffer : Byte[MAX_PACKET_SIZE]
var position : Integer = setHeader(buffer, 27)
//finalize(buffer, position)
network!packet(buffer)
end

internal event m : out?m2 action
do
var buffer : Byte[MAX_PACKET_SIZE]
var position : Integer = setHeader(buffer, 1)
serializeInteger(m.i, buffer, position)
position = position + lengthInteger()
//finalize(buffer, position)
network!packet(buffer)
end

internal event m : out?m3 action
do
var buffer : Byte[MAX_PACKET_SIZE]
var position : Integer = setHeader(buffer, 2)
serializeString(m.s, buffer, position)
position = position + lengthString()
//finalize(buffer, position)
network!packet(buffer)
end

internal event m : out?m4 action
do
var buffer : Byte[MAX_PACKET_SIZE]
var position : Integer = setHeader(buffer, 12)
serializeInteger(m.i, buffer, position)
position = position + lengthInteger()
serializeString(m.s, buffer, position)
position = position + lengthString()
//finalize(buffer, position)
network!packet(buffer)
end

}
}

}

thing MessageDeserializer includes DataTypeSerializerScala, Network, RemoteMsgs {
required port in{
sends m1, m2, m3, m4
}

provided port network {
receives packet
}

function deserializeM1(buffer : Byte[MAX_PACKET_SIZE])
do
var position : Integer = CODE_POSITION + 1
in!m1()
end

function deserializeM2(buffer : Byte[MAX_PACKET_SIZE])
do
var position : Integer = CODE_POSITION + 1
readonly var i : Integer = deserializeInteger(buffer, position)
position = position + lengthInteger()
in!m2(i)
end

function deserializeM3(buffer : Byte[MAX_PACKET_SIZE])
do
var position : Integer = CODE_POSITION + 1
readonly var s : String = deserializeString(buffer, position)
position = position + lengthString()
in!m3(s)
end

function deserializeM4(buffer : Byte[MAX_PACKET_SIZE])
do
var position : Integer = CODE_POSITION + 1
readonly var i : Integer = deserializeInteger(buffer, position)
position = position + lengthInteger()
readonly var s : String = deserializeString(buffer, position)
position = position + lengthString()
in!m4(i, s)
end

statechart DeserializerBehavior init Deserialize {
state Deserialize {
internal event packet : network?packet action
do
readonly var buffer : Byte[MAX_PACKET_SIZE] = packet.p
readonly var code : Integer = buffer[CODE_POSITION]
if (code == 27) do
deserializeM1(buffer)
end
if (code == 1) do
deserializeM2(buffer)
end
if (code == 2) do
deserializeM3(buffer)
end
if (code == 12) do
deserializeM4(buffer)
end
end
}
}
}

/**
 * @remote annotations allows defining which ports are remote
 * syntax: instanceName::TypeName::PortName::messageName
 * note: wildcards can be used for any of these elements.
 */
configuration test 
@remote "testRemote::TestThing::.*::.*"
{
    //Messages are sent and received without serialization
    instance test : TestThing
    connector test.out => test.in
    
    //Messages are serialized, sent to (simulated) network, received, deserialized and sent to the former thing
    //hopefully, this has the same behavior than the configuration above...
    instance testRemote : TestThing
    instance net : Network
    instance serializer : MessageSerializer
    instance deserializer : MessageDeserializer
    
    connector testRemote.out => serializer.out
    connector serializer.network => net.in_net
    connector net.out_net => deserializer.network
    connector deserializer.in => testRemote.in
    
}