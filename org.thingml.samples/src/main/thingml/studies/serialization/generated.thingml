import "../../core/_scala/serializer.thingml"
import "../../core/serializer.thingml"
import "../../core/comm.thingml"
import "../../core/timer.thingml"
import "../../core/_scala/timer.thingml"

//test messages
thing fragment testMsgs {
    message m4(i : Integer, s : String);
    message m2(i : Integer);
    message m1();
    message m3(s : String);
}

//test thing
thing TestThing includes testMsgs
@mock "true"
{
    required port out {
       sends m1, m2, m3, m4
    }
    
    provided port in {
       receives m1, m2, m3, m4
    }        
}

//All the code below is generated
thing fragment RemoteMsgs includes testMsgs{
//message m1();//code=27
//message m2(i : Integer);//code=1
//message m3(s : String);//code=2
//message m4(i : Integer, s : String);//code=12
}

thing MessageSerializer includes SerializerScala, OutputByteStreamMsgs, RemoteMsgs, TimerClient {
provided port out{
receives m1, m2, m3, m4
}

statechart SerializerBehavior init Serialize {
state Serialize{
transition -> Communication event m : out?m1 action
do
setHeader(27, 0)
end
transition -> Communication event m : out?m2 action
do
setHeader(1, 0+lengthInteger)
serializeInteger(m.i)
end
transition -> Communication event m : out?m3 action
do
setHeader(2, 0+lengthString)
serializeString(m.s)
end
transition -> Communication event m : out?m4 action
do
setHeader(12, 0+lengthInteger+lengthString)
serializeInteger(m.i)
serializeString(m.s)
end
}
composite state Communication init send {
on entry do
index = 0
network!write_byte(START_BYTE)
timer!timer_start(DELAY)
end
on exit do
network!write_byte(STOP_BYTE)
end
transition -> Serialize event m : timer?timer_timeout
guard index == DATA_POSITION + buffer[LENGTH_POSITION]
state send {
internal event t : timer?timer_timeout
guard index < DATA_POSITION + buffer[LENGTH_POSITION]
action do
network!write_byte(readByte())
timer!timer_start(DELAY)
end
}
}
}
}

thing MessageDeserializer includes DeserializerScala, InputByteStreamMsgs, RemoteMsgs {
required port in{
sends m1, m2, m3, m4
}

function forward() do
index = DATA_POSITION
readonly var code : Byte = buffer[CODE_POSITION]
if (code == 27) do
deserializeM1()
end
if (code == 1) do
deserializeM2()
end
if (code == 2) do
deserializeM3()
end
if (code == 12) do
deserializeM4()
end
end

function deserializeM1()
do
in!m1()
end

function deserializeM2()
do
readonly var i : Integer = deserializeInteger()
in!m2(i)
end

function deserializeM3()
do
readonly var s : String = deserializeString()
in!m3(s)
end

function deserializeM4()
do
readonly var i : Integer = deserializeInteger()
readonly var s : String = deserializeString()
in!m4(i, s)
end

statechart receive init Idle {
state Idle {
on entry index = 0
transition -> ReceiveMessage event m : network?receive_byte
guard m.b == START_BYTE
}
state ReceiveMessage {
transition -> Escape event m : network?receive_byte
guard m.b == ESCAPE_BYTE
internal event m : network?receive_byte
guard not (m.b == ESCAPE_BYTE or m.b == STOP_BYTE)
action storeByte(m.b)
transition -> Idle event m : network?receive_byte
guard m.b == STOP_BYTE
action forward()
internal event m : network?receive_byte
guard m.b == START_BYTE // Should not happen with a reliable channel
action index = 0 // Reset if it happens (some bytes have been lost at some point)
}
state Escape {
transition receive -> ReceiveMessage
event m : network?receive_byte
action storeByte(m.b)
}
}
}


/**
 * @remote annotations allows defining which ports are remote
 * syntax: instanceName::TypeName::PortName::messageName
 * note: wildcards can be used for any of these elements.
 */
configuration test 
@remote "testRemote::TestThing::.*::.*"
{
    //Messages are sent and received without serialization
    instance test : TestThing
    connector test.out => test.in
    
    //Messages are serialized, sent to (simulated) network, received, deserialized and sent to the former thing
    //hopefully, this has the same behavior than the configuration above...
    instance testRemote : TestThing
    instance network : Network
    instance serializer : MessageSerializer
    instance deserializer : MessageDeserializer
    instance timer : TimerScala
    
    connector testRemote.out => serializer.out
    connector serializer.network => network.IOStream
    connector serializer.timer => timer.timer
    connector deserializer.network => network.IOStream
    connector deserializer.in => testRemote.in
    
}