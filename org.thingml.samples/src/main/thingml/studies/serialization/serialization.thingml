import "../../core/_scala/serializer.thingml"
import "../../core/serializer.thingml"

//test messages
thing fragment testMsgs {
    message m4(i : Integer, s : String);
    message m2(i : Integer);
    message m1();
    message m3(s : String);
}

//test thing
thing TestThing includes testMsgs
@mock "true"
{
    required port out {
       sends m1, m2, m3, m4
    }
    
    provided port in {
       receives m1, m2, m3, m4
    }        
}

/*
*  This is what we should generate to handle the serialization 
* of all the remote messages send by an application
*/
thing MessageSerializer includes DataTypeSerializerScala, Network, testMsgs{
    
    provided port in_serial {
       receives m1, m2, m3, m4
    }
    
    required port network {
        sends packet    
    }
    
    statechart SerializerBehavior init Serialize {
        state Serialize{
             internal event m : in_serial?m1 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer, 1)
                 
                 //finalize(buffer, position)
                 network!packet(buffer)
             end
             
             internal event m : in_serial?m2 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer, 2)
                 
                 serializeInteger(m.i, buffer, position)
                 position = position + lengthInteger()
                 
                 //finalize(buffer, position)
                 network!packet(buffer)
             end
             
             internal event m : in_serial?m3 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer, 3)
                 
                 serializeString(m.s, buffer, position)
                 position = position + lengthString()
                 
                 //finalize(buffer, position)
                 network!packet(buffer)
             end
             
             internal event m : in_serial?m4 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer, 4)
                 
                 serializeInteger(m.i, buffer, position)
                 position = position + lengthInteger()
                 
                 serializeString(m.s, buffer, position)
                 position = position + lengthString()
                 
                 //finalize(buffer, position)
                 network!packet(buffer)
             end
        }
    }
}

/*
*  This is what we should generate to handler the serialization 
* of all the remote messages received by an application
*/
thing MessageDeserializer includes DataTypeSerializerScala, Network, testMsgs {
    required port out_serial {
       sends m1, m2, m3, m4
    }
    
    provided port network {
        receives packet    
    }
    
    function deserializeM1(buffer : Byte[MAX_PACKET_SIZE]) 
    do
        out_serial!m1()
    end
    
    function deserializeM2(buffer : Byte[MAX_PACKET_SIZE]) 
    do
        var position : Integer = CODE_POSITION + 1
        readonly var i : Integer = deserializeInteger(buffer, position)
        out_serial!m2(i)
    end
    
    function deserializeM3(buffer : Byte[MAX_PACKET_SIZE]) 
    do
        var position : Integer = CODE_POSITION + 1
        readonly var s : String = deserializeString(buffer, position)
        out_serial!m3(s)
    end
    
    function deserializeM4(buffer : Byte[MAX_PACKET_SIZE]) 
    do
        var position : Integer = CODE_POSITION + 1
        readonly var i : Integer = deserializeInteger(buffer, position)
        position = position + lengthInteger()
        readonly var s : String = deserializeString(buffer, position)
        out_serial!m4(i, s)
    end
            
     statechart DeserializerBehavior init Deserialize {
        state Deserialize {
         internal event packet : network?packet action 
             do
                 readonly var buffer : Byte[MAX_PACKET_SIZE] = packet.p
                 readonly var code : Integer = buffer[CODE_POSITION]
                 if (code == 1) do//we need else in ThingML so that the code generated can be more performant
                    deserializeM1(buffer)
                 end
                 if (code == 2) do
                    deserializeM2(buffer)
                 end
                 if (code == 3) do
                    deserializeM3(buffer)
                 end
                 if (code == 4) do
                    deserializeM4(buffer)
                 end
             end    
            
        }    
     }
}

/**
 * @remote annotations allows defining which ports are remote
 * syntax: instanceName::TypeName::PortName::messageName
 * note: wildcards can be used for any of these elements.
 */
configuration test 
@remote "testRemote::TestThing::.*::.*"
{
    //Messages are sent and received without serialization
    instance test : TestThing
    connector test.out => test.in
    
    //Messages are serialized, sent to (simulated) network, received, deserialized and sent to the former thing
    //hopefully, this has the same behavior than the configuration above...
    instance testRemote : TestThing
    instance net : Network
    instance serializer : MessageSerializer
    instance deserializer : MessageDeserializer
    
    connector testRemote.out => serializer.in_serial
    connector serializer.network => net.in_net
    connector net.out_net => deserializer.network
    connector deserializer.out_serial => testRemote.in
    
}