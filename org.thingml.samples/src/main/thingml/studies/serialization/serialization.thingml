datatype Integer
@scala_type "Int";

datatype String
@scala_type "String";

datatype Byte
@scala_type "Byte";

thing fragment testMsgs {
    message m1();
    message m2(i : Integer);
    message m3(s : String);
    message m4(i : Integer, s : String);
}

thing testThing includes testMsgs{
    required port out {
       sends m1, m2, m3, m4
    }
    
    provided port in {
       receives m1, m2, m3, m4
    }        
}

/*
*  For all serializable datatype called D, define:
*  - lengthD() : Integer, which returns the size in bytes of the serialized type
*  - serializeD(d : D, bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer), which puts the serialized datatype in the buffer, starting at bytes[startPosition]
*  - deserializeD(bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) : D, which gets the datatype from its serialized form, starting from bytes[startPosition]
*/
thing fragment DataTypeSerializerScala  includes PacketManager
{
    function lengthInteger() : Integer
    do
        return 1
    end
    
    function serializeInteger(d : Integer, bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer)
    do
        bytes[startPosition] = '' & d & '.toByte'
    end
    
    function deserializeInteger(bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) : Integer
    do
        return 'bytes(startPosition).toInt'
    end    
    

    function lengthString() : Integer
    do
        return 8
    end
            
    function serializeString(d : String, bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) 
    do
        var i : Integer = startPosition
        while(i < startPosition+lengthString() and i < MAX_PACKET_SIZE) do
            if (i < '' & d & '.size')
                bytes[i] = 'd(' & i-startPosition & ').toByte'
            if (i > '' & d & '.size' - 1)//We need an else in ThingML
                bytes[i] = '0.toByte'
            i = i + 1
        end
        return bytes
    end
    
    function deserializeString(bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) : String 
    do
        var result : String
        var i : Integer = 0
        while(i < 8) do
            result = result + 'bytes(i).toChar'
            i = i + 1
        end
        return bytes
    end
}

thing fragment PacketManager {
     readonly property MAX_PACKET_SIZE : Integer = 16   
     
     readonly property START_BYTE : Byte = '0x12'
	 readonly property STOP_BYTE : Byte = '0x13'
	 readonly property ESCAPE_BYTE : Byte = '0x7D'
     readonly property PAD_BYTE : Byte = '0x00'
     
     function setHeader(buffer : Byte[MAX_PACKET_SIZE]) : Integer do
	 	buffer[0] = START_BYTE
	 	buffer[1] = 1 // source addr (not used)
	 	buffer[2] = 0 // target addr (not used)
	 	buffer[3] = 0 // frame num (not used)
        return 4//position of the next byte to be written
	 end

    function pad(buffer : Byte[16], startPosition : Integer, stopPosition : Integer) do
        var i : Integer = 0
        while (i < stopPosition) do
            buffer[i] = PAD_BYTE
        end
    end
}

thing Network includes PacketManager 
@mock "true"
{
    message packet(p : Byte[MAX_PACKET_SIZE]);
    
    provided port in {
        receives packet    
    }    

    required port in {
        sends packet    
    }    
}

/*
*  This is what we should generate to handler the serialization 
* of all the remote messages send by an application
*/
thing MessageSerializer includes DataTypeSerializerScala, testMsgs{
    
    provided port in {
       receives m1, m2, m3, m4
    }
    
    //TODO: add a port to send on the network
    
    statechart SerializerBehavior init Serialize {
        state Serialize{
             internal event m : in?m1 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer)
                 buffer[position] = 1//code of the message
                 position = position + 1
                 pad(buffer, position, MAX_PACKET_SIZE - 1)
                 buffer[MAX_PACKET_SIZE - 1] = STOP_BYTE
                 //TODO: send to network
             end
             
             internal event m : in?m2 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer)
                 buffer[position] = 2//code of the message
                 position = position + 1
                 
                 serializeInteger(m.i, buffer, position)
                 position = position + lengthInteger()
                 
                 pad(buffer, position, MAX_PACKET_SIZE - 1)
                 buffer[MAX_PACKET_SIZE - 1] = STOP_BYTE
                 //TODO: send to network
             end
             
             internal event m : in?m3 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer)
                 buffer[position] = 2//code of the message
                 position = position + 1
                 
                 serializeString(m.s, buffer, position)
                 position = position + lengthString()
                 
                 pad(buffer, position, MAX_PACKET_SIZE - 1)
                 buffer[MAX_PACKET_SIZE - 1] = STOP_BYTE
                 //TODO: send to network
             end
             
             internal event m : in?m4 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer)
                 buffer[position] = 2//code of the message
                 position = position + 1
                 
                 serializeInteger(m.i, buffer, position)
                 position = position + lengthInteger()
                 
                 serializeString(m.s, buffer, position)
                 position = position + lengthString()
                 
                 pad(buffer, position, MAX_PACKET_SIZE - 1)
                 buffer[MAX_PACKET_SIZE - 1] = STOP_BYTE
                 //TODO: send to network
             end
        }
    }
}

/*
*  This is what we should generate to handler the serialization 
* of all the remote messages received by an application
*/
thing MessageDeserializer includes testMsgs, PacketManager{
    required port out {
       sends m1, m2, m3, m4
    }
    
    //TODO: add a port to receive from the network
            
     statechart DeserializerBehavior init Deserialize {
        state Deserialize {}    
     }
}

configuration test {
    
}