import "../../datatypes.thingml"

/*datatype Crisis
@java_type "bcms.Crisis";

datatype Route
@java_type "bcms.Route";

datatype TimeoutLog
@java_type "bcms.TimeoutLog";*/


thing fragment bCMSMsgs 
/*@maven_dep
"<dependency>
   <groupId>aom</groupId>
   <artifactId>aom.bcms</artifactId>
   <version>0.0.1-SNAPSHOT</version>
</dependency>"*/
{
    //1.
    message initCom(id : String);
    //2.
    message crisisDetails(id : String, lat : Double, lon : Double, time : Long, isActive : Boolean, desc : String);
    //3.
    message numberOfTrucks(number : Long);
    message route(crisisID : String, pVehicles : Long, fVehicles : Long, path : String);   
    message ackRoute();
    //4. Note: we ack all vehicles, not each of them individually, yet
    message dispatched();
    //5. Note: we ack all vehicles, not each of them individually, yet
    message arrived();
    //6.
    message done();
    //7.
    message close();
}


thing fragment PSC_Interface includes bCMSMsgs {

    required port out {
    	sends initCom, crisisDetails, numberOfTrucks, route, dispatched, arrived, done, close
    }    
    
    provided port in {
        receives initCom, crisisDetails, numberOfTrucks, ackRoute, dispatched, arrived, done, close
    }
    
}

thing fragment FSC_Interface includes bCMSMsgs {
    
    required port out {
    	sends initCom, crisisDetails, numberOfTrucks, ackRoute, dispatched, arrived, done, close
    }    
    
    provided port in {
        receives initCom, crisisDetails, numberOfTrucks, route, dispatched, arrived, done, close
    }
    
}

//bCMS acts as a mediator / channel between PSC and FSC
thing fragment bCMS_Interface includes bCMSMsgs {
     
     provided port fromPSC {
    	receives initCom, crisisDetails, numberOfTrucks, route, dispatched, arrived, done, close
     } 
     
     required port toPSC {
        sends initCom, crisisDetails, numberOfTrucks, ackRoute, dispatched, arrived, done, close         
     }   
     
     provided port fromFSC {
    	receives initCom, crisisDetails, numberOfTrucks, ackRoute, dispatched, arrived, done, close
    }
    
    required port toFSC {
    	sends initCom, crisisDetails, numberOfTrucks, route, dispatched, arrived, done, close
    }
}



thing FSC_Mock includes FSC_Interface
@mock "true"
{}

thing PSC_Mock includes PSC_Interface
@mock "true"
{}

thing bCMS_Mock includes bCMS_Interface
@mock "true"
{}

/*configuration agreeOnScenario {
    instance psc : PSC_Mock    
    instance fsc : FSC_Mock
    instance bcms : bCMS_Mock
    
    connector psc.out => bcms.fromPSC
    connector bcms.toPSC => psc.in
    connector fsc.out => bcms.fromFSC
    connector bcms.toFSC => fsc.in
}*/


thing fragment GUIbCMSMsgs {
    //1.
    message gui_initCom(activate : Boolean);
    //2.
    message gui_crisisDetails(activate : Boolean);
    //3.
    message gui_numberOfTrucks(activate : Boolean);
    message gui_route(activate : Boolean);   
    message gui_ackRoute(activate : Boolean);
    //4.
    message gui_dispatched(activate : Boolean);
    //5.
    message gui_arrived(activate : Boolean);
    //6.
    message gui_done(activate : Boolean);
    //7.
    message gui_close(activate : Boolean);    
}

////////////////////////PSC////////////////////////

datatype PSC_GUI
@java_type "org.thingml.generated.PSC_MockMock";

thing PSC_GUI includes GUIbCMSMsgs, bCMSMsgs 
@java_interface "org.thingml.generated.PSC_MockListener" 
{

	readonly property gui : PSC_GUI = 'new org.thingml.generated.PSC_MockMock()'

    provided port control {
        receives gui_initCom, gui_crisisDetails, gui_numberOfTrucks, gui_route, gui_dispatched, gui_arrived, gui_done, gui_close
    }
    
    required port out {
    	sends initCom, crisisDetails, numberOfTrucks, route, dispatched, arrived, done, close
    }    
    
      
    /**
    * Call backs for the GUI
    */
    function onInitCom_via_out(id : String) @implements "true"
    do 
        out!initCom(id)
    end
    
    function onCrisisDetails_via_out(id : String, lat : Double, lon : Double, time : Long, isActive : Boolean, desc : String) @implements "true"
    do 
        out!crisisDetails(id, lat, lon, time, isActive, desc)
    end
    
    function onNumberOfTrucks_via_out(number : Long) @implements "true"
    do 
        out!numberOfTrucks(number)
        //numberPolicsTrucks = number
    end
    
    function onRoute_via_out(crisisID : String, pVehicles : Long, fVehicles : Long, path : String) @implements "true"
    do 
        out!route(crisisID, pVehicles, fVehicles, path)
    end
    
    function onDispatched_via_out() @implements "true"
    do 
        out!dispatched()
    end
    
    function onArrived_via_out() @implements "true"
    do 
        out!arrived()
    end
    
    function onDone_via_out() @implements "true"
    do 
        out!done()
    end
    
    function onClose_via_out() @implements "true"
    do 
        out!close()
    end

	statechart behavior init Init {
	
		on entry do
            '' & gui & '.listeners.add(root.asInstanceOf[org.thingml.generated.PSC_MockListener]);'
            //'' & gui & '.sendinitCom_via_out.setEnabled(true);'
		end
	
		state Init {}

        internal event c : control?gui_initCom
        action '' & gui & '.sendinitCom_via_out.setEnabled(' & c.activate & ');'
        
        internal event c : control?gui_crisisDetails
        action '' & gui & '.sendcrisisDetails_via_out.setEnabled(' & c.activate & ');'

        internal event c : control?gui_numberOfTrucks
        action '' & gui & '.sendnumberOfTrucks_via_out.setEnabled(' & c.activate & ');'

        internal event c : control?gui_route
        action '' & gui & '.sendroute_via_out.setEnabled(' & c.activate & ');'
        
        internal event c : control?gui_dispatched
        action '' & gui & '.senddispatched_via_out.setEnabled(' & c.activate & ');'
        
        internal event c : control?gui_arrived
        action '' & gui & '.sendarrived_via_out.setEnabled(' & c.activate & ');'

        internal event c : control?gui_done
        action '' & gui & '.senddone_via_out.setEnabled(' & c.activate & ');'
        
        internal event c : control?gui_close
        action '' & gui & '.sendclose_via_out.setEnabled(' & c.activate & ');'
               
	}

         
}

thing PSC includes PSC_Interface, GUIbCMSMsgs {

    required port control {
        sends gui_initCom, gui_crisisDetails, gui_numberOfTrucks, gui_route, gui_dispatched, gui_arrived, gui_done, gui_close
    }
    
    provided port feedback {
    	receives initCom, crisisDetails, numberOfTrucks, route, dispatched, arrived, done, close
    }
    
    message initComOK();
    
    provided port internIN {
        receives initComOK
    }    
    
    required port internOUT {
        sends initComOK
    }    
    
    property fscID : String
    property numberFireTrucks : Long
    property numberPolicsTrucks : Long
    
    	statechart behavior init Wait4Com {
	
		on entry do
            //control!gui_initCom(false)
            control!gui_crisisDetails(false)
            control!gui_numberOfTrucks(false)
            control!gui_route(false)
            control!gui_dispatched(false)
            control!gui_arrived(false)
            control!gui_done(false)
            control!gui_close(false)
		end
	
        //1.
		state Wait4Com {
			on entry do
				control!gui_initCom(true)
			end
			
			on exit do
				control!gui_initCom(false)
			end
			
			transition -> Wait4CrisisDetails
			event internIN?initComOK
		}
		
        //2.
		state Wait4CrisisDetails {
			on entry do
				control!gui_crisisDetails(true)
			end

            on exit do
				control!gui_crisisDetails(false)
			end

            /*transition -> CoordinateRoute
			event cd : in?crisisDetails
			action do end*/		
	   }

       //3. 
 /*      composite state CoordinateRoute init DefineTrucks {
           
           //3.1
           state DefineTrucks {
            on entry do
				'' & gui & '.sendnumberOfTrucks_via_out.setEnabled(true);'
			end
			
			/*on exit do
				'' & gui & '.sendnumberOfTrucks_via_out.setEnabled(false);'
			end*/

  /*          transition -> DefineRoute
			event t : in?numberOfTrucks
			action do 
                numberFireTrucks = t.number
                //TODO: we should update the GUI to pre-fill the fields for the next step, with truck numbers, etc.
            end		
           }
        
           //3.2   
           state DefineRoute {
            on entry do
				'' & gui & '.sendroute_via_out.setEnabled(true);'
			end
			
			/*on exit do
				'' & gui & '.sendroute_via_out.setEnabled(false);'
			end*/               
    /*       }
           
           
       }
       
       
        //4.
		state Wait4Dispatch {
			on entry do
				'' & gui & '.senddispatched_via_out.setEnabled(true);'
			end
			
			/*on exit do
				'' & gui & '.senddispatched_via_out.setEnabled(false);'
			end*/
			
/*			transition -> Wait4Arrival
			event d : in?dispatched
			action do
			end
		}

        //5.
		state Wait4Arrival {
			on entry do
				'' & gui & '.sendarrived_via_out.setEnabled(true);'
			end
			
			/*on exit do
				'' & gui & '.sendarrived_via_out.setEnabled(false);'
			end*/
			
/*			transition -> Wait4Completion
			event d : in?arrived
			action do
			end
		}

        //6.
		state Wait4Completion {
			on entry do
				'' & gui & '.senddone_via_out.setEnabled(true);'
			end
			
			/*on exit do
				'' & gui & '.senddone_via_out.setEnabled(false);'
			end*/
/*			
			transition -> Wait4Close
			event d : in?done
			action do
			end
		}

        //7.
		state Wait4Close {
			on entry do
				'' & gui & '.sendclose_via_out.setEnabled(true);'
			end
			
			/*on exit do
				'' & gui & '.sendclose_via_out.setEnabled(false);'
			end*/
			
/*			transition -> Wait4Com
			event d : in?close
			action do
			end
		}
*/
        region CEP init Wait4Com {    
            
            state Wait4Com{
                property gui : Boolean
                property fire : Boolean
                
                on entry
                do
                 gui = false
                 fire = false
                end
                
                internal event feedback?initCom
                guard not fire
                action do 
                    gui = true
                end
                
                internal event com : in?initCom
                guard not gui
                action do 
                    fire = true
                    fscID = com.id
                end
                
                transition -> Wait4CrisisDetails
                event in?initCom
                event feedback?initCom
                //guard gui and fire
                action do
                    internOUT!initComOK()
                end
                
            }
            
            state Wait4CrisisDetails {
                property gui : Boolean
                property fire : Boolean
                
                on entry
                do
                 gui = false
                 fire = false
                end
                
                internal event feedback?crisisDetails
                guard not fire
                action do 
                    gui = true
                end
                
                internal event in?crisisDetails
                guard not gui
                action do 
                    fire = true
                end
                
                transition -> Wait4CrisisDetails
                event in?crisisDetails
                event feedback?crisisDetails
                //guard gui and fire
                
            }
            
            
        }
                        
	
	}

}


configuration mainScenario {
    instance psc_gui : PSC_GUI    
    instance psc : PSC  
    instance bcms : bCMS_Mock
    
    connector psc_gui.out => psc.feedback
    connector psc.control => psc_gui.control
    connector psc.out => bcms.fromPSC
    connector psc.internOUT => psc.internIN
    connector bcms.toPSC => psc.in
}

//////////////////////PSC END//////////////////////

