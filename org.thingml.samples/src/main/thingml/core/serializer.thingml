import "../datatypes.thingml"

//Just a mock for the network
thing Network includes PacketManager 
{
    message packet(p : Byte[MAX_PACKET_SIZE]);
    
    provided port in_net {
        receives packet    
    }    

    required port out_net {
        sends packet    
    }
    
    statechart NetworkBehavior init default {
        state default {
            internal event p : in_net?packet 
            action out_net!packet(p.p)    
        }    
    }
}

//Defines constants and methods to manage fixed size packets
/*
*  For all serializable datatype called D (D is the name of the ThingML datatype, not the underlying platform-specific datatype), define:
*  - lengthD() : Integer, which returns the size in bytes of the serialized type. This should be defined here to ensure the consistencies of all serializer.
*  - serializeD(d : D, bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer), which puts the serialized datatype in the buffer, starting at bytes[startPosition]. This should be defined in a PSM thing that include this thing.
*  - deserializeD(bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) : D, which gets the datatype from its serialized form, starting from bytes[startPosition]. This should be defined in a PSM thing that include this thing.
*  The idea is inspired by the ByteBuffer provided by Java (http://download.oracle.com/javase/1.4.2/docs/api/java/nio/ByteBuffer.html), 
*  but this implementation aims at being as independent as possible to any specific platform, so that ThingML can seamlessly compile to different plaforms (Scala/Java, C, etc)
* 
*  ThingML comes along with serialize/deserialise functions for all the datatypes defined in the ThingML framework.
*  User defined datatypes that needs to be serialized should come along these functions.
*/
thing fragment PacketManager {
     readonly property MAX_PACKET_SIZE : Integer = 16   
     
     readonly property START_BYTE : Byte = '0x12'
	 readonly property STOP_BYTE : Byte = '0x13'
	 readonly property ESCAPE_BYTE : Byte = '0x7D'
     readonly property PADDING_BYTE : Byte = '0x00'
     
     readonly property CODE_POSITION : Integer = 4
     
     function setHeader(buffer : Byte[MAX_PACKET_SIZE], code : Byte) : Integer 
     do
	 	buffer[0] = START_BYTE
	 	buffer[1] = 1 // source addr (not used)
	 	buffer[2] = 0 // target addr (not used)
	 	buffer[3] = 0 // frame num (not used)
        buffer[4] = code
        finalize(buffer, 5)//pads and puts the STOP_BYTE. Note that too long messages will erase the stop byte, meaning that the message will be discarded at some point in the communication chain.
        return 5//position of the next byte to be written
	 end

    function finalize(buffer : Byte[MAX_PACKET_SIZE], startPosition : Integer)
    do
        readonly var endPosition : Integer = MAX_PACKET_SIZE - 1
        pad(buffer, startPosition, endPosition)
        buffer[endPosition] = STOP_BYTE
    end

    function pad(buffer : Byte[MAX_PACKET_SIZE], startPosition : Integer, stopPosition : Integer) 
    do
        var i : Integer = startPosition
        while (i < stopPosition and i < MAX_PACKET_SIZE -1) 
        do
            buffer[i] = PADDING_BYTE
            i = i +1
        end
    end
    
    //Define the length of all the datatypes
    //TODO: do it for all datatypes
    function lengthInteger() : Integer
    do
        return 1
    end
    
    function lengthString() : Integer
    do
        return 8
    end
}