import "../datatypes.thingml"
import "./comm.thingml"

//Defines constants and methods to manage variable size packets (with maximum size defined by MAX_PACKET_SIZE)
/*
*  For all serializable datatype called D (D is the name of the ThingML datatype, not the underlying platform-specific datatype), define:
*  - lengthD() : Integer, which returns the size in bytes of the serialized type. This should be defined here to ensure the consistencies of all serializer. However, datatypes whose size is determined dynamically (eg, VarString) should define this method in a PSm thing.
*  - serializeD(d : D, bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer), which puts the serialized datatype in the buffer, starting at bytes[startPosition]. This should be defined in a PSM thing that include this thing.
*  - deserializeD(bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) : D, which gets the datatype from its serialized form, starting from bytes[startPosition]. This should be defined in a PSM thing that include this thing.
*  The idea is inspired by the ByteBuffer provided by Java (http://download.oracle.com/javase/1.4.2/docs/api/java/nio/ByteBuffer.html), 
*  but this implementation aims at being as independent as possible to any specific platform, so that ThingML can seamlessly compile to different plaforms (Scala/Java, C, etc)
* 
*  ThingML comes along with serialize/deserialise functions for all the datatypes defined in the ThingML framework.
*  User defined datatypes that needs to be serialized should come along these functions.
*/
thing fragment PacketManager {
        //Define the length (in bytes) of all the datatypes
        //TODO: Do it for all the other datatypes provided by ThingML
    readonly property lengthInteger : Byte = 1    
    readonly property lengthString : Byte = 8
    
    
    readonly property MAX_PACKET_SIZE : Integer = 16   
     
    readonly property START_BYTE : Byte = '0x12'
	readonly property STOP_BYTE : Byte = '0x13'
	readonly property ESCAPE_BYTE : Byte = '0x7D'
     
    readonly property DELAY : UInt8 = 1
     
    property CODE_POSITION : Integer = 3
    property LENGTH_POSITION : Integer = 4
    property DATA_POSITION : Integer = 5
     
    property buffer : Byte[16]
    set buffer[0] = '0x13'
    set buffer[1] = '0x13'
    set buffer[2] = '0x13'
    set buffer[3] = '0x13'
    set buffer[4] = '0x13'
    set buffer[5] = '0x13'
    set buffer[6] = '0x13'
    set buffer[7] = '0x13'
    set buffer[8] = '0x13'
    set buffer[9] = '0x13'
    set buffer[10] = '0x13'
    set buffer[11] = '0x13'
    set buffer[12] = '0x13'
    set buffer[13] = '0x13'
    set buffer[14] = '0x13'
    set buffer[15] = '0x13'
	property index : Integer = 5
     
     function setHeader(code : Byte, length : Byte) 
     do
        index = 0
	 	storeByte(1) // source addr (not used)
	 	storeByte(0) // target addr (not used)
	 	storeByte(0) // frame num (not used)
        CODE_POSITION = index
        storeByte(code)
        LENGTH_POSITION = index
        storeByte(length)
        DATA_POSITION = index
	 end

    function storeByte(b : Byte) do
        if (index < MAX_PACKET_SIZE) do
	 	  buffer[index] = b
		  index = index + 1
        end
        if (index == MAX_PACKET_SIZE) do
            error("BUFFER OVERFLOW: " + b + "has been ignored")
        end
	end

    function readByte() : Byte do
        var b : Byte
        if (index < MAX_PACKET_SIZE) do
	 	  b = buffer[index]
          index = index + 1
        end
        if (index == MAX_PACKET_SIZE) do
          error("BUFFER OVERFLOW: trying to read out of buffer boundaries")
          b = STOP_BYTE
        end
        return b
	end
}

thing fragment Serializer includes PacketManager, OutputByteStreamMsgs {
    required port network {
        sends write_byte    
    }
    
    function send() do
        print("send start byte = " + START_BYTE)
        network!write_byte(START_BYTE)
        readonly var stop : Integer = DATA_POSITION + buffer[LENGTH_POSITION] - 1
        var i : Integer = 0
        while(i < stop) do
            var b : Byte = buffer[i]
            if (b == START_BYTE or b == STOP_BYTE or b == ESCAPE_BYTE) do
                print("send escape byte = " + ESCAPE_BYTE)
                network!write_byte(ESCAPE_BYTE)
            end
            print("send data byte(" + i + ") = " + b)
            network!write_byte(b)
            i = i + 1
        end
        print("send stop byte = " + STOP_BYTE)
        network!write_byte(STOP_BYTE)
        index = 0
    end
}

thing fragment Deserializer includes PacketManager, InputByteStreamMsgs{
    required port network {
        receives receive_byte    
    }
    
    //function receive() do end//should be refined in a PSM thing
}

thing fragment ArraySerializer includes PacketManager, OutputByteArrayMsgs {
    property packet : Byte[18]
    set packet[0] = '0x12'
    set packet[17] = '0x13'
    required port network {
        sends write_bytes    
    }
    
    function send() do
        print("send byte array = " + buffer)
        var i : Integer = 1
        while (i < 17) do
            packet[i] = buffer[i-1]
            i = i + 1
        end
        i = 0
        while (i < 18) do
            print("packet " + i + " = " + packet[i])
            i = i + 1
        end
        network!write_bytes(packet)
    end
}

thing fragment ArrayDeserializer includes PacketManager, InputByteArrayMsgs{
    required port network {
        receives receive_bytes    
    }
    
    function forward()@abstract "true" do end//should be refined in a PSM thing
    
    function receive(bytes : Byte[256]) do
        index = 0
        //print("receive " + bytes)
        var i : Integer = 0
        var current : Byte = bytes[i]
        //print("byte " + i + " = " + current)
        if (current == START_BYTE) do
            //print("Start OK")
            i = i + 1
            while(not (current == STOP_BYTE) and i < 256) do
                current = bytes[i]
                if (current == ESCAPE_BYTE and i < 255) do
                    i = i + 1
                    current = buffer[i]
                end
                //print("byte " + i + " = " + current)
                storeByte(current)
                i = i + 1
            end
            if (current == STOP_BYTE) do
                forward()
            end
            if (not(current == STOP_BYTE)) do//ie index>=256
                error("It seems the packet was too long... (No stop byte was found before index 256)")
            end
        end
    end
}