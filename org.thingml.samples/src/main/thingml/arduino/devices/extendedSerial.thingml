import "../core/arduino.thingml"
import "serial.thingml"

thing fragment ExtendedSerialMsgs includes SerialMsgs {
	message receiveValue (v : Int16);
}

thing fragment IsDigitMsgs {
    message char(c : Byte);
	message isDigit(b : Boolean, c : Byte);
}

thing fragment IsDigit includes IsDigitMsgs {
    
	provided port testDigit {
		receives char
		sends isDigit
	}
	
	statechart IsDigitImpl init Run {
		state Run {
			internal event m : testDigit?char
			action do
				if (47 < m.c < 58 ) testDigit!isDigit(true, m.c)
				if (not (47 < m.c < 58)) testDigit!isDigit(false, m.c)
				end
		}
	}
}

thing ExtendedSerial includes IsDigitMsgs, ExtendedSerialMsgs, ArduinoStdlibMsgs
{
    
    //readonly property bufferSize : Int8 = 20
	//property buffer : String = 'malloc (' & bufferSize & '* sizeof (char))'
	property buffer : String = '(char *)malloc (20 * sizeof (char))'
	property index : Int8 = 0

	required port serial {
        receives receiveByte
        sends printByte, printMessage, printValue
	}
	
	required port testDigit {
		sends char
		receives isDigit
	}
	
	provided port extSerial {
		sends receiveByte, receiveValue
        receives printByte, printMessage, printValue
	}

    statechart ExtendedSerialImpl init Receiving {
            
        state Receiving 
        {    
            //* Redirecting print actions to basic serial device.
            internal event m : extSerial?printByte
            action serial!printByte(m.b)
            
            internal event m : extSerial?printMessage
            action serial!printMessage(m.msg)
            
            internal event m : extSerial?printValue
            action serial!printValue(m.v)
            //*
            
        	internal event m : serial?receiveByte
            guard not (m.b == '\'$\'')
            action extSerial!receiveByte(m.b)
                
            transition readNumber -> Buf
            event m : serial?receiveByte
            guard m.b == '\'$\''      
            action serial!printMessage("Reading a Number\n") // Debug                             
        }
        
        state Buf {
        	on entry index = 0
        
        	transition -> Receiving
        	event m : serial?receiveByte
        	guard m.b == '\'\n\'' and not (index == 0) // To avoid the first '\n' which comes with the '$'.
        	action ''& buffer &'['& index & '] = \'\0\';' 
        	after extSerial!receiveValue('atoi('& buffer &')')
        	
        	// Send the byte to check if it's a digit like supposed.
        	internal event m : serial?receiveByte
            guard not (m.b == '\'\n\'')
            action testDigit!char(m.b)
            	
            // Add the digit to the buffer.	
        	internal event m : testDigit?isDigit
            guard m.b == true  // No effect!
            action do
            	''& buffer &'['& index & '] = '& m.c &';'
            	index = index + 1
            	end	
        }
    }
}

configuration extendedSerialFrag {
	instance serial : Serial
	instance exSerial : ExtendedSerial
    instance testdigit : IsDigit
	connector exSerial.serial => serial.serial
    connector exSerial.testDigit => testdigit.testDigit 
}