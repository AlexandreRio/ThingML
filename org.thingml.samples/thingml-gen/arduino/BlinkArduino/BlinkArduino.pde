
/***************************************************************************** 
 * File generated from ThingML (Do not edit this file) 
 *****************************************************************************/


/*****************************************************************************
 * Definition of simple types and enumerations
 *****************************************************************************/

// Definition of Enumeration  DigitalState
#define DIGITALSTATE_LOW 0
#define DIGITALSTATE_HIGH 1

// Definition of Enumeration  PinMode
#define PINMODE_INPUT 0
#define PINMODE_OUTPUT 1

// Definition of Enumeration  DigitalPin
#define DIGITALPIN_PIN_0 0
#define DIGITALPIN_PIN_1 1
#define DIGITALPIN_PIN_2 2
#define DIGITALPIN_PIN_3 3
#define DIGITALPIN_PIN_4 4
#define DIGITALPIN_PIN_5 5
#define DIGITALPIN_PIN_6 6
#define DIGITALPIN_PIN_7 7
#define DIGITALPIN_PIN_8 8
#define DIGITALPIN_PIN_9 9
#define DIGITALPIN_PIN_10 10
#define DIGITALPIN_PIN_11 11
#define DIGITALPIN_PIN_12 12
#define DIGITALPIN_PIN_13 13
#define DIGITALPIN_A_0 14
#define DIGITALPIN_A_1 15
#define DIGITALPIN_A_2 16
#define DIGITALPIN_A_3 17
#define DIGITALPIN_A_4 18
#define DIGITALPIN_A_5 19

// Definition of Enumeration  PWMPin
#define PWMPIN_PWM_PIN_3 3
#define PWMPIN_PWM_PIN_5 5
#define PWMPIN_PWM_PIN_6 6
#define PWMPIN_PWM_PIN_9 9
#define PWMPIN_PWM_PIN_10 10
#define PWMPIN_PWM_PIN_11 11

// Definition of Enumeration  AnalogPin
#define ANALOGPIN_A_0 14
#define ANALOGPIN_A_1 15
#define ANALOGPIN_A_2 16
#define ANALOGPIN_A_3 17
#define ANALOGPIN_A_4 18
#define ANALOGPIN_A_5 19

// Definition of Enumeration  AnalogReference
#define ANALOGREFERENCE_DEFAULT 1
#define ANALOGREFERENCE_INTERNAL 3
#define ANALOGREFERENCE_EXTERNAL 0

// Definition of Enumeration  InterruptPin
#define INTERRUPTPIN_PIN_2_INT0 0
#define INTERRUPTPIN_PIN_3_INT1 1

// Definition of Enumeration  InterruptTrigger
#define INTERRUPTTRIGGER_CHANGE 1
#define INTERRUPTTRIGGER_RISING 3
#define INTERRUPTTRIGGER_FALLING 2
#define INTERRUPTTRIGGER_LOW 0

/*****************************************************************************
 * Headers for type : DigitalOutputArduino
 *****************************************************************************/


// BEGIN: Code from the c_header annotation DigitalOutputArduino
#include <EEPROM.h>
// END: Code from the c_header annotation DigitalOutputArduino

// Definition of the instance stuct:
struct DigitalOutputArduino_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int DigitalOutputArduino_DigitalOutpuImpl_State;
// Variables for the properties of the instance
uint8_t DigitalOutputArduino_pin__var;
};

// Declaration of prototypes outgoing messages:
void DigitalOutputArduino_DigitalOutpuImpl_OnEntry(int state, struct DigitalOutputArduino_Instance *_instance);
void DigitalOutputArduino_handle_DigitalOutput_set_digital_output(struct DigitalOutputArduino_Instance *_instance, uint8_t value);
// Declaration of callbacks for incomming messages:
void register_DigitalOutputArduino_send_DigitalIO_pin_mode_listener(void (*_listener)(struct DigitalOutputArduino_Instance*, uint8_t, uint8_t));
void register_DigitalOutputArduino_send_DigitalIO_digital_write_listener(void (*_listener)(struct DigitalOutputArduino_Instance*, uint8_t, uint8_t));

// Definition of the states:
#define DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_STATE 0
#define DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_RUNNING_STATE 1

/*****************************************************************************
 * Implementation for type : DigitalOutputArduino
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void DigitalOutputArduino_DigitalOutpuImpl_OnExit(int state, struct DigitalOutputArduino_Instance *_instance);
void DigitalOutputArduino_send_DigitalIO_pin_mode(struct DigitalOutputArduino_Instance *_instance, uint8_t pin, uint8_t mode);
void DigitalOutputArduino_send_DigitalIO_digital_write(struct DigitalOutputArduino_Instance *_instance, uint8_t pin, uint8_t value);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void DigitalOutputArduino_DigitalOutpuImpl_OnEntry(int state, struct DigitalOutputArduino_Instance *_instance) {
switch(state) {
case DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_STATE:
_instance->DigitalOutputArduino_DigitalOutpuImpl_State = DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_RUNNING_STATE;
DigitalOutputArduino_send_DigitalIO_pin_mode(_instance, _instance->DigitalOutputArduino_pin__var, PINMODE_OUTPUT);
DigitalOutputArduino_DigitalOutpuImpl_OnEntry(_instance->DigitalOutputArduino_DigitalOutpuImpl_State, _instance);
break;
case DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_RUNNING_STATE:
break;
default: break;
}
}

// On Exit Actions:
void DigitalOutputArduino_DigitalOutpuImpl_OnExit(int state, struct DigitalOutputArduino_Instance *_instance) {
switch(state) {
case DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_STATE:
DigitalOutputArduino_DigitalOutpuImpl_OnExit(_instance->DigitalOutputArduino_DigitalOutpuImpl_State, _instance);
break;
case DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_RUNNING_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void DigitalOutputArduino_handle_DigitalOutput_set_digital_output(struct DigitalOutputArduino_Instance *_instance, uint8_t value) {
uint8_t DigitalOutputArduino_DigitalOutpuImpl_State_event_consumed = 0;
if (_instance->DigitalOutputArduino_DigitalOutpuImpl_State == DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_RUNNING_STATE) {
if (DigitalOutputArduino_DigitalOutpuImpl_State_event_consumed == 0 && 1) {
DigitalOutputArduino_send_DigitalIO_digital_write(_instance, _instance->DigitalOutputArduino_pin__var, value);
DigitalOutputArduino_DigitalOutpuImpl_State_event_consumed = 1;
}
}
}

// Observers for outgoing messages:
void (*DigitalOutputArduino_send_DigitalIO_pin_mode_listener)(struct DigitalOutputArduino_Instance*, uint8_t, uint8_t)= 0x0;
void register_DigitalOutputArduino_send_DigitalIO_pin_mode_listener(void (*_listener)(struct DigitalOutputArduino_Instance*, uint8_t, uint8_t)){
DigitalOutputArduino_send_DigitalIO_pin_mode_listener = _listener;
}
void DigitalOutputArduino_send_DigitalIO_pin_mode(struct DigitalOutputArduino_Instance *_instance, uint8_t pin, uint8_t mode){
if (DigitalOutputArduino_send_DigitalIO_pin_mode_listener != 0x0) DigitalOutputArduino_send_DigitalIO_pin_mode_listener(_instance, pin, mode);
}
void (*DigitalOutputArduino_send_DigitalIO_digital_write_listener)(struct DigitalOutputArduino_Instance*, uint8_t, uint8_t)= 0x0;
void register_DigitalOutputArduino_send_DigitalIO_digital_write_listener(void (*_listener)(struct DigitalOutputArduino_Instance*, uint8_t, uint8_t)){
DigitalOutputArduino_send_DigitalIO_digital_write_listener = _listener;
}
void DigitalOutputArduino_send_DigitalIO_digital_write(struct DigitalOutputArduino_Instance *_instance, uint8_t pin, uint8_t value){
if (DigitalOutputArduino_send_DigitalIO_digital_write_listener != 0x0) DigitalOutputArduino_send_DigitalIO_digital_write_listener(_instance, pin, value);
}

/*****************************************************************************
 * Headers for type : Blink
 *****************************************************************************/

// Definition of the instance stuct:
struct Blink_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int Blink_BlinkImpl_State;
// Variables for the properties of the instance
};

// Declaration of prototypes outgoing messages:
void Blink_BlinkImpl_OnEntry(int state, struct Blink_Instance *_instance);
void Blink_handle_HW_timer_timeout(struct Blink_Instance *_instance);
// Declaration of callbacks for incomming messages:
void register_Blink_send_HW_led_toggle_listener(void (*_listener)(struct Blink_Instance*));
void register_Blink_send_HW_timer_start_listener(void (*_listener)(struct Blink_Instance*, int));

// Definition of the states:
#define BLINK_BLINKIMPL_STATE 0
#define BLINK_BLINKIMPL_BLINKING_STATE 1

/*****************************************************************************
 * Implementation for type : Blink
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void Blink_BlinkImpl_OnExit(int state, struct Blink_Instance *_instance);
void Blink_send_HW_led_toggle(struct Blink_Instance *_instance);
void Blink_send_HW_timer_start(struct Blink_Instance *_instance, int delay);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void Blink_BlinkImpl_OnEntry(int state, struct Blink_Instance *_instance) {
switch(state) {
case BLINK_BLINKIMPL_STATE:
_instance->Blink_BlinkImpl_State = BLINK_BLINKIMPL_BLINKING_STATE;
Blink_BlinkImpl_OnEntry(_instance->Blink_BlinkImpl_State, _instance);
break;
case BLINK_BLINKIMPL_BLINKING_STATE:
Blink_send_HW_timer_start(_instance, 1000);
break;
default: break;
}
}

// On Exit Actions:
void Blink_BlinkImpl_OnExit(int state, struct Blink_Instance *_instance) {
switch(state) {
case BLINK_BLINKIMPL_STATE:
Blink_BlinkImpl_OnExit(_instance->Blink_BlinkImpl_State, _instance);
break;
case BLINK_BLINKIMPL_BLINKING_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void Blink_handle_HW_timer_timeout(struct Blink_Instance *_instance) {
uint8_t Blink_BlinkImpl_State_event_consumed = 0;
if (_instance->Blink_BlinkImpl_State == BLINK_BLINKIMPL_BLINKING_STATE) {
if (Blink_BlinkImpl_State_event_consumed == 0 && 1) {
Blink_BlinkImpl_OnExit(BLINK_BLINKIMPL_BLINKING_STATE, _instance);
_instance->Blink_BlinkImpl_State = BLINK_BLINKIMPL_BLINKING_STATE;
Blink_send_HW_led_toggle(_instance);
Blink_BlinkImpl_OnEntry(BLINK_BLINKIMPL_BLINKING_STATE, _instance);
Blink_BlinkImpl_State_event_consumed = 1;
}
}
}

// Observers for outgoing messages:
void (*Blink_send_HW_led_toggle_listener)(struct Blink_Instance*)= 0x0;
void register_Blink_send_HW_led_toggle_listener(void (*_listener)(struct Blink_Instance*)){
Blink_send_HW_led_toggle_listener = _listener;
}
void Blink_send_HW_led_toggle(struct Blink_Instance *_instance){
if (Blink_send_HW_led_toggle_listener != 0x0) Blink_send_HW_led_toggle_listener(_instance);
}
void (*Blink_send_HW_timer_start_listener)(struct Blink_Instance*, int)= 0x0;
void register_Blink_send_HW_timer_start_listener(void (*_listener)(struct Blink_Instance*, int)){
Blink_send_HW_timer_start_listener = _listener;
}
void Blink_send_HW_timer_start(struct Blink_Instance *_instance, int delay){
if (Blink_send_HW_timer_start_listener != 0x0) Blink_send_HW_timer_start_listener(_instance, delay);
}

/*****************************************************************************
 * Headers for type : ArduinoArduino
 *****************************************************************************/


// BEGIN: Code from the c_header annotation ArduinoArduino
#include <EEPROM.h>
// END: Code from the c_header annotation ArduinoArduino

// Definition of the instance stuct:
struct ArduinoArduino_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int ArduinoArduino_ArduinoArduino_State;
// Variables for the properties of the instance
};

// Declaration of prototypes outgoing messages:
void ArduinoArduino_ArduinoArduino_OnEntry(int state, struct ArduinoArduino_Instance *_instance);
void ArduinoArduino_handle_AnalogIO_analog_reference(struct ArduinoArduino_Instance *_instance, uint8_t type);
void ArduinoArduino_handle_AnalogIO_analog_write(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value);
void ArduinoArduino_handle_AnalogIO_analog_read(struct ArduinoArduino_Instance *_instance, uint8_t pin);
void ArduinoArduino_handle_Ping_ping(struct ArduinoArduino_Instance *_instance);
void ArduinoArduino_handle_AdvancedIO_no_tone(struct ArduinoArduino_Instance *_instance, uint8_t pin);
void ArduinoArduino_handle_AdvancedIO_tone(struct ArduinoArduino_Instance *_instance, uint8_t pin, int frequency, int duration);
void ArduinoArduino_handle_EEPROM_eeprom_write(struct ArduinoArduino_Instance *_instance, int address, int8_t value);
void ArduinoArduino_handle_EEPROM_eeprom_read(struct ArduinoArduino_Instance *_instance, int address);
void ArduinoArduino_handle_EEPROM_eeprom_sync_write(struct ArduinoArduino_Instance *_instance, int address, int8_t value);
void ArduinoArduino_handle_DigitalIO_digital_write(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value);
void ArduinoArduino_handle_DigitalIO_pin_mode(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t mode);
void ArduinoArduino_handle_DigitalIO_digital_read(struct ArduinoArduino_Instance *_instance, uint8_t pin);
// Declaration of callbacks for incomming messages:
void register_ArduinoArduino_send_DigitalIO_digital_read_result_listener(void (*_listener)(struct ArduinoArduino_Instance*, uint8_t, uint8_t));
void register_ArduinoArduino_send_AnalogIO_analog_read_result_listener(void (*_listener)(struct ArduinoArduino_Instance*, uint8_t, int));
void register_ArduinoArduino_send_Ping_pong_listener(void (*_listener)(struct ArduinoArduino_Instance*));
void register_ArduinoArduino_send_EEPROM_eeprom_value_listener(void (*_listener)(struct ArduinoArduino_Instance*, int8_t));
void register_ArduinoArduino_send_EEPROM_eeprom_write_ack_listener(void (*_listener)(struct ArduinoArduino_Instance*));

// Definition of the states:
#define ARDUINOARDUINO_ARDUINOARDUINO_STATE 0
#define ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE 1

/*****************************************************************************
 * Implementation for type : ArduinoArduino
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void ArduinoArduino_ArduinoArduino_OnExit(int state, struct ArduinoArduino_Instance *_instance);
void ArduinoArduino_send_DigitalIO_digital_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value);
void ArduinoArduino_send_AnalogIO_analog_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, int value);
void ArduinoArduino_send_Ping_pong(struct ArduinoArduino_Instance *_instance);
void ArduinoArduino_send_EEPROM_eeprom_value(struct ArduinoArduino_Instance *_instance, int8_t value);
void ArduinoArduino_send_EEPROM_eeprom_write_ack(struct ArduinoArduino_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void ArduinoArduino_ArduinoArduino_OnEntry(int state, struct ArduinoArduino_Instance *_instance) {
switch(state) {
case ARDUINOARDUINO_ARDUINOARDUINO_STATE:
_instance->ArduinoArduino_ArduinoArduino_State = ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE;
ArduinoArduino_ArduinoArduino_OnEntry(_instance->ArduinoArduino_ArduinoArduino_State, _instance);
break;
case ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE:
break;
default: break;
}
}

// On Exit Actions:
void ArduinoArduino_ArduinoArduino_OnExit(int state, struct ArduinoArduino_Instance *_instance) {
switch(state) {
case ARDUINOARDUINO_ARDUINOARDUINO_STATE:
ArduinoArduino_ArduinoArduino_OnExit(_instance->ArduinoArduino_ArduinoArduino_State, _instance);
break;
case ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void ArduinoArduino_handle_AnalogIO_analog_reference(struct ArduinoArduino_Instance *_instance, uint8_t type) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
analogReference(type);
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_AnalogIO_analog_write(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
analogWrite(pin, value);
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_AnalogIO_analog_read(struct ArduinoArduino_Instance *_instance, uint8_t pin) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
ArduinoArduino_send_AnalogIO_analog_read_result(_instance, pin, analogRead(pin));
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_Ping_ping(struct ArduinoArduino_Instance *_instance) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
ArduinoArduino_send_Ping_pong(_instance);
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_AdvancedIO_no_tone(struct ArduinoArduino_Instance *_instance, uint8_t pin) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
noTone(pin);
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_AdvancedIO_tone(struct ArduinoArduino_Instance *_instance, uint8_t pin, int frequency, int duration) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
tone(pin, frequency, duration);
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_EEPROM_eeprom_write(struct ArduinoArduino_Instance *_instance, int address, int8_t value) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
EEPROM.write(address, value);
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_EEPROM_eeprom_read(struct ArduinoArduino_Instance *_instance, int address) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
ArduinoArduino_send_EEPROM_eeprom_value(_instance, EEPROM.read(address));
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_EEPROM_eeprom_sync_write(struct ArduinoArduino_Instance *_instance, int address, int8_t value) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
{
EEPROM.write(address, value);
ArduinoArduino_send_EEPROM_eeprom_write_ack(_instance);
}
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_DigitalIO_digital_write(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
digitalWrite(pin, value);
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_DigitalIO_pin_mode(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t mode) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
pinMode(pin, mode);
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}
void ArduinoArduino_handle_DigitalIO_digital_read(struct ArduinoArduino_Instance *_instance, uint8_t pin) {
uint8_t ArduinoArduino_ArduinoArduino_State_event_consumed = 0;
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (ArduinoArduino_ArduinoArduino_State_event_consumed == 0 && 1) {
ArduinoArduino_send_DigitalIO_digital_read_result(_instance, pin, digitalRead(pin));
ArduinoArduino_ArduinoArduino_State_event_consumed = 1;
}
}
}

// Observers for outgoing messages:
void (*ArduinoArduino_send_DigitalIO_digital_read_result_listener)(struct ArduinoArduino_Instance*, uint8_t, uint8_t)= 0x0;
void register_ArduinoArduino_send_DigitalIO_digital_read_result_listener(void (*_listener)(struct ArduinoArduino_Instance*, uint8_t, uint8_t)){
ArduinoArduino_send_DigitalIO_digital_read_result_listener = _listener;
}
void ArduinoArduino_send_DigitalIO_digital_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value){
if (ArduinoArduino_send_DigitalIO_digital_read_result_listener != 0x0) ArduinoArduino_send_DigitalIO_digital_read_result_listener(_instance, pin, value);
}
void (*ArduinoArduino_send_AnalogIO_analog_read_result_listener)(struct ArduinoArduino_Instance*, uint8_t, int)= 0x0;
void register_ArduinoArduino_send_AnalogIO_analog_read_result_listener(void (*_listener)(struct ArduinoArduino_Instance*, uint8_t, int)){
ArduinoArduino_send_AnalogIO_analog_read_result_listener = _listener;
}
void ArduinoArduino_send_AnalogIO_analog_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, int value){
if (ArduinoArduino_send_AnalogIO_analog_read_result_listener != 0x0) ArduinoArduino_send_AnalogIO_analog_read_result_listener(_instance, pin, value);
}
void (*ArduinoArduino_send_Ping_pong_listener)(struct ArduinoArduino_Instance*)= 0x0;
void register_ArduinoArduino_send_Ping_pong_listener(void (*_listener)(struct ArduinoArduino_Instance*)){
ArduinoArduino_send_Ping_pong_listener = _listener;
}
void ArduinoArduino_send_Ping_pong(struct ArduinoArduino_Instance *_instance){
if (ArduinoArduino_send_Ping_pong_listener != 0x0) ArduinoArduino_send_Ping_pong_listener(_instance);
}
void (*ArduinoArduino_send_EEPROM_eeprom_value_listener)(struct ArduinoArduino_Instance*, int8_t)= 0x0;
void register_ArduinoArduino_send_EEPROM_eeprom_value_listener(void (*_listener)(struct ArduinoArduino_Instance*, int8_t)){
ArduinoArduino_send_EEPROM_eeprom_value_listener = _listener;
}
void ArduinoArduino_send_EEPROM_eeprom_value(struct ArduinoArduino_Instance *_instance, int8_t value){
if (ArduinoArduino_send_EEPROM_eeprom_value_listener != 0x0) ArduinoArduino_send_EEPROM_eeprom_value_listener(_instance, value);
}
void (*ArduinoArduino_send_EEPROM_eeprom_write_ack_listener)(struct ArduinoArduino_Instance*)= 0x0;
void register_ArduinoArduino_send_EEPROM_eeprom_write_ack_listener(void (*_listener)(struct ArduinoArduino_Instance*)){
ArduinoArduino_send_EEPROM_eeprom_write_ack_listener = _listener;
}
void ArduinoArduino_send_EEPROM_eeprom_write_ack(struct ArduinoArduino_Instance *_instance){
if (ArduinoArduino_send_EEPROM_eeprom_write_ack_listener != 0x0) ArduinoArduino_send_EEPROM_eeprom_write_ack_listener(_instance);
}

/*****************************************************************************
 * Headers for type : TimerArduino
 *****************************************************************************/

// Definition of the instance stuct:
struct TimerArduino_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int TimerArduino_SoftTimer_State;
// Variables for the properties of the instance
long TimerArduino_SoftTimer_target__var;
};

// Declaration of prototypes outgoing messages:
void TimerArduino_SoftTimer_OnEntry(int state, struct TimerArduino_Instance *_instance);
void TimerArduino_handle_Polling_poll(struct TimerArduino_Instance *_instance);
void TimerArduino_handle_timer_timer_start(struct TimerArduino_Instance *_instance, int delay);
void TimerArduino_handle_timer_timer_cancel(struct TimerArduino_Instance *_instance);
// Declaration of callbacks for incomming messages:
void register_TimerArduino_send_timer_timer_timeout_listener(void (*_listener)(struct TimerArduino_Instance*));

// Definition of the states:
#define TIMERARDUINO_SOFTTIMER_STATE 0
#define TIMERARDUINO_SOFTTIMER_IDLE_STATE 1
#define TIMERARDUINO_SOFTTIMER_COUNTING_STATE 2

/*****************************************************************************
 * Implementation for type : TimerArduino
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void TimerArduino_SoftTimer_OnExit(int state, struct TimerArduino_Instance *_instance);
void TimerArduino_send_timer_timer_timeout(struct TimerArduino_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void TimerArduino_SoftTimer_OnEntry(int state, struct TimerArduino_Instance *_instance) {
switch(state) {
case TIMERARDUINO_SOFTTIMER_STATE:
_instance->TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_IDLE_STATE;
TimerArduino_SoftTimer_OnEntry(_instance->TimerArduino_SoftTimer_State, _instance);
break;
case TIMERARDUINO_SOFTTIMER_IDLE_STATE:
break;
case TIMERARDUINO_SOFTTIMER_COUNTING_STATE:
break;
default: break;
}
}

// On Exit Actions:
void TimerArduino_SoftTimer_OnExit(int state, struct TimerArduino_Instance *_instance) {
switch(state) {
case TIMERARDUINO_SOFTTIMER_STATE:
TimerArduino_SoftTimer_OnExit(_instance->TimerArduino_SoftTimer_State, _instance);
break;
case TIMERARDUINO_SOFTTIMER_IDLE_STATE:
break;
case TIMERARDUINO_SOFTTIMER_COUNTING_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void TimerArduino_handle_Polling_poll(struct TimerArduino_Instance *_instance) {
uint8_t TimerArduino_SoftTimer_State_event_consumed = 0;
if (_instance->TimerArduino_SoftTimer_State == TIMERARDUINO_SOFTTIMER_COUNTING_STATE) {
if (TimerArduino_SoftTimer_State_event_consumed == 0 &&  !(millis() < _instance->TimerArduino_SoftTimer_target__var)) {
TimerArduino_SoftTimer_OnExit(TIMERARDUINO_SOFTTIMER_COUNTING_STATE, _instance);
_instance->TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_IDLE_STATE;
TimerArduino_SoftTimer_OnEntry(TIMERARDUINO_SOFTTIMER_IDLE_STATE, _instance);
TimerArduino_send_timer_timer_timeout(_instance);
TimerArduino_SoftTimer_State_event_consumed = 1;
}
}
}
void TimerArduino_handle_timer_timer_start(struct TimerArduino_Instance *_instance, int delay) {
uint8_t TimerArduino_SoftTimer_State_event_consumed = 0;
if (_instance->TimerArduino_SoftTimer_State == TIMERARDUINO_SOFTTIMER_IDLE_STATE) {
if (TimerArduino_SoftTimer_State_event_consumed == 0 && delay > 0) {
TimerArduino_SoftTimer_OnExit(TIMERARDUINO_SOFTTIMER_IDLE_STATE, _instance);
_instance->TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_COUNTING_STATE;
_instance->TimerArduino_SoftTimer_target__var = millis() + delay;
TimerArduino_SoftTimer_OnEntry(TIMERARDUINO_SOFTTIMER_COUNTING_STATE, _instance);
TimerArduino_SoftTimer_State_event_consumed = 1;
}
}
else if (_instance->TimerArduino_SoftTimer_State == TIMERARDUINO_SOFTTIMER_COUNTING_STATE) {
if (TimerArduino_SoftTimer_State_event_consumed == 0 && delay > 0) {
_instance->TimerArduino_SoftTimer_target__var = millis() + delay;
TimerArduino_SoftTimer_State_event_consumed = 1;
}
}
}
void TimerArduino_handle_timer_timer_cancel(struct TimerArduino_Instance *_instance) {
uint8_t TimerArduino_SoftTimer_State_event_consumed = 0;
if (_instance->TimerArduino_SoftTimer_State == TIMERARDUINO_SOFTTIMER_COUNTING_STATE) {
if (TimerArduino_SoftTimer_State_event_consumed == 0 && 1) {
TimerArduino_SoftTimer_OnExit(TIMERARDUINO_SOFTTIMER_COUNTING_STATE, _instance);
_instance->TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_IDLE_STATE;
TimerArduino_SoftTimer_OnEntry(TIMERARDUINO_SOFTTIMER_IDLE_STATE, _instance);
TimerArduino_SoftTimer_State_event_consumed = 1;
}
}
}

// Observers for outgoing messages:
void (*TimerArduino_send_timer_timer_timeout_listener)(struct TimerArduino_Instance*)= 0x0;
void register_TimerArduino_send_timer_timer_timeout_listener(void (*_listener)(struct TimerArduino_Instance*)){
TimerArduino_send_timer_timer_timeout_listener = _listener;
}
void TimerArduino_send_timer_timer_timeout(struct TimerArduino_Instance *_instance){
if (TimerArduino_send_timer_timer_timeout_listener != 0x0) TimerArduino_send_timer_timer_timeout_listener(_instance);
}

/*****************************************************************************
 * Headers for type : LedUC
 *****************************************************************************/

// Definition of the instance stuct:
struct LedUC_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int LedUC_LedImpl_State;
// Variables for the properties of the instance
};

// Declaration of prototypes outgoing messages:
void LedUC_LedImpl_OnEntry(int state, struct LedUC_Instance *_instance);
void LedUC_handle_Led_led_toggle(struct LedUC_Instance *_instance);
void LedUC_handle_Led_led_on(struct LedUC_Instance *_instance);
void LedUC_handle_Led_led_off(struct LedUC_Instance *_instance);
// Declaration of callbacks for incomming messages:
void register_LedUC_send_DigitalOutput_set_digital_output_listener(void (*_listener)(struct LedUC_Instance*, uint8_t));

// Definition of the states:
#define LEDUC_LEDIMPL_STATE 0
#define LEDUC_LEDIMPL_LEDOFF_STATE 1
#define LEDUC_LEDIMPL_LEDON_STATE 2

/*****************************************************************************
 * Implementation for type : LedUC
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void LedUC_LedImpl_OnExit(int state, struct LedUC_Instance *_instance);
void LedUC_send_DigitalOutput_set_digital_output(struct LedUC_Instance *_instance, uint8_t value);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void LedUC_LedImpl_OnEntry(int state, struct LedUC_Instance *_instance) {
switch(state) {
case LEDUC_LEDIMPL_STATE:
_instance->LedUC_LedImpl_State = LEDUC_LEDIMPL_LEDOFF_STATE;
LedUC_LedImpl_OnEntry(_instance->LedUC_LedImpl_State, _instance);
break;
case LEDUC_LEDIMPL_LEDOFF_STATE:
LedUC_send_DigitalOutput_set_digital_output(_instance, DIGITALSTATE_LOW);
break;
case LEDUC_LEDIMPL_LEDON_STATE:
LedUC_send_DigitalOutput_set_digital_output(_instance, DIGITALSTATE_HIGH);
break;
default: break;
}
}

// On Exit Actions:
void LedUC_LedImpl_OnExit(int state, struct LedUC_Instance *_instance) {
switch(state) {
case LEDUC_LEDIMPL_STATE:
LedUC_LedImpl_OnExit(_instance->LedUC_LedImpl_State, _instance);
break;
case LEDUC_LEDIMPL_LEDOFF_STATE:
break;
case LEDUC_LEDIMPL_LEDON_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void LedUC_handle_Led_led_toggle(struct LedUC_Instance *_instance) {
uint8_t LedUC_LedImpl_State_event_consumed = 0;
if (_instance->LedUC_LedImpl_State == LEDUC_LEDIMPL_LEDOFF_STATE) {
if (LedUC_LedImpl_State_event_consumed == 0 && 1) {
LedUC_LedImpl_OnExit(LEDUC_LEDIMPL_LEDOFF_STATE, _instance);
_instance->LedUC_LedImpl_State = LEDUC_LEDIMPL_LEDON_STATE;
LedUC_LedImpl_OnEntry(LEDUC_LEDIMPL_LEDON_STATE, _instance);
LedUC_LedImpl_State_event_consumed = 1;
}
}
else if (_instance->LedUC_LedImpl_State == LEDUC_LEDIMPL_LEDON_STATE) {
if (LedUC_LedImpl_State_event_consumed == 0 && 1) {
LedUC_LedImpl_OnExit(LEDUC_LEDIMPL_LEDON_STATE, _instance);
_instance->LedUC_LedImpl_State = LEDUC_LEDIMPL_LEDOFF_STATE;
LedUC_LedImpl_OnEntry(LEDUC_LEDIMPL_LEDOFF_STATE, _instance);
LedUC_LedImpl_State_event_consumed = 1;
}
}
}
void LedUC_handle_Led_led_on(struct LedUC_Instance *_instance) {
uint8_t LedUC_LedImpl_State_event_consumed = 0;
if (_instance->LedUC_LedImpl_State == LEDUC_LEDIMPL_LEDOFF_STATE) {
if (LedUC_LedImpl_State_event_consumed == 0 && 1) {
LedUC_LedImpl_OnExit(LEDUC_LEDIMPL_LEDOFF_STATE, _instance);
_instance->LedUC_LedImpl_State = LEDUC_LEDIMPL_LEDON_STATE;
LedUC_LedImpl_OnEntry(LEDUC_LEDIMPL_LEDON_STATE, _instance);
LedUC_LedImpl_State_event_consumed = 1;
}
}
}
void LedUC_handle_Led_led_off(struct LedUC_Instance *_instance) {
uint8_t LedUC_LedImpl_State_event_consumed = 0;
if (_instance->LedUC_LedImpl_State == LEDUC_LEDIMPL_LEDON_STATE) {
if (LedUC_LedImpl_State_event_consumed == 0 && 1) {
LedUC_LedImpl_OnExit(LEDUC_LEDIMPL_LEDON_STATE, _instance);
_instance->LedUC_LedImpl_State = LEDUC_LEDIMPL_LEDOFF_STATE;
LedUC_LedImpl_OnEntry(LEDUC_LEDIMPL_LEDOFF_STATE, _instance);
LedUC_LedImpl_State_event_consumed = 1;
}
}
}

// Observers for outgoing messages:
void (*LedUC_send_DigitalOutput_set_digital_output_listener)(struct LedUC_Instance*, uint8_t)= 0x0;
void register_LedUC_send_DigitalOutput_set_digital_output_listener(void (*_listener)(struct LedUC_Instance*, uint8_t)){
LedUC_send_DigitalOutput_set_digital_output_listener = _listener;
}
void LedUC_send_DigitalOutput_set_digital_output(struct LedUC_Instance *_instance, uint8_t value){
if (LedUC_send_DigitalOutput_set_digital_output_listener != 0x0) LedUC_send_DigitalOutput_set_digital_output_listener(_instance, value);
}


/*****************************************************************************
 * Definitions for configuration : BlinkArduino
 *****************************************************************************/

#define MAX_INSTANCES 32
#define FIFO_SIZE 256

/*********************************
 * Instance IDs and lookup
 *********************************/

void * instances[MAX_INSTANCES];
uint16_t instances_count = 0;

void * instance_by_id(uint16_t id) {
  return instances[id];
}

uint16_t add_instance(void * instance_struct) {
  instances[instances_count] = instance_struct;
  return instances_count++;
}

/******************************************
 * Simple byte FIFO implementation
 ******************************************/

byte fifo[FIFO_SIZE];
int fifo_head = 0;
int fifo_tail = 0;

// Returns the number of byte currently in the fifo
int fifo_byte_length() {
  if (fifo_tail >= fifo_head)
    return fifo_tail - fifo_head;
  return fifo_tail + FIFO_SIZE - fifo_head;
}

// Returns the number of bytes currently available in the fifo
int fifo_byte_available() {
  return FIFO_SIZE - 1 - fifo_byte_length();
}

// Returns true if the fifo is empty
int fifo_empty() {
  return fifo_head == fifo_tail;
}

// Return true if the fifo is full
int fifo_full() {
  return fifo_head == ((fifo_tail + 1) % FIFO_SIZE);
}

// Enqueue 1 byte in the fifo if there is space
// returns 1 for sucess and 0 if the fifo was full
int fifo_enqueue(byte b) {
  int new_tail = (fifo_tail + 1) % FIFO_SIZE;
  if (new_tail == fifo_head) return 0; // the fifo is full
  fifo[fifo_tail] = b;
  fifo_tail = new_tail;
  return 1;
}

// Enqueue 1 byte in the fifo without checking for available space
// The caller should have checked that there is enough space
int _fifo_enqueue(byte b) {
  fifo[fifo_tail] = b;
  fifo_tail = (fifo_tail + 1) % FIFO_SIZE;
}

// Dequeue 1 byte in the fifo.
// The caller should check that the fifo is not empty
byte fifo_dequeue() {
  if (!fifo_empty()) {
    byte result = fifo[fifo_head];
    fifo_head = (fifo_head + 1) % FIFO_SIZE;
    return result;
  }
  return 0;
}

/*
void _fifo_enqueue_ptr(void * ptr) {
  int i;
  ptr_union_t proxy;
  proxy.pointer = ptr;
  for (i = 0; i<PTR_MAX_SIZE; i++) _fifo_enqueue(proxy.buffer[i]);
}

void * _fifo_dequeue_ptr() {
  int i;
  ptr_union_t proxy;
  for (i = 0; i<PTR_MAX_SIZE; i++) proxy.buffer[i] = _fifo_dequeue();
  return proxy.pointer;
}
*/
//Declaration of instance variables
struct LedUC_Instance BlinkArduino_led_led_var;
struct ArduinoArduino_Instance BlinkArduino_led_io_arduino_var;
struct Blink_Instance BlinkArduino_app_var;
struct TimerArduino_Instance BlinkArduino_timer_var;
struct DigitalOutputArduino_Instance BlinkArduino_led_io_digital_output_var;

// Enqueue of messages Blink::HW::led_toggle
void enqueue_Blink_send_HW_led_toggle(struct Blink_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (1 >> 8) & 0xFF );
_fifo_enqueue( 1 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}
// Enqueue of messages Blink::HW::timer_start
void enqueue_Blink_send_HW_timer_start(struct Blink_Instance *_instance, int delay){
if ( fifo_byte_available() > 6 ) {

_fifo_enqueue( (2 >> 8) & 0xFF );
_fifo_enqueue( 2 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter delay
_fifo_enqueue((delay>>8) & 0xFF);
_fifo_enqueue(delay & 0xFF);
}
}
// Enqueue of messages DigitalOutputArduino::DigitalIO::digital_write
void enqueue_DigitalOutputArduino_send_DigitalIO_digital_write(struct DigitalOutputArduino_Instance *_instance, uint8_t pin, uint8_t value){
if ( fifo_byte_available() > 6 ) {

_fifo_enqueue( (3 >> 8) & 0xFF );
_fifo_enqueue( 3 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);

// parameter value
_fifo_enqueue(value & 0xFF);
}
}
// Enqueue of messages DigitalOutputArduino::DigitalIO::pin_mode
void enqueue_DigitalOutputArduino_send_DigitalIO_pin_mode(struct DigitalOutputArduino_Instance *_instance, uint8_t pin, uint8_t mode){
if ( fifo_byte_available() > 6 ) {

_fifo_enqueue( (4 >> 8) & 0xFF );
_fifo_enqueue( 4 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);

// parameter mode
_fifo_enqueue(mode & 0xFF);
}
}
// Enqueue of messages TimerArduino::timer::timer_timeout
void enqueue_TimerArduino_send_timer_timer_timeout(struct TimerArduino_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (5 >> 8) & 0xFF );
_fifo_enqueue( 5 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}
// Enqueue of messages LedUC::DigitalOutput::set_digital_output
void enqueue_LedUC_send_DigitalOutput_set_digital_output(struct LedUC_Instance *_instance, uint8_t value){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (6 >> 8) & 0xFF );
_fifo_enqueue( 6 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter value
_fifo_enqueue(value & 0xFF);
}
}

// Dispatch for messages LedUC::DigitalOutput::set_digital_output
void dispatch_LedUC_send_DigitalOutput_set_digital_output(struct LedUC_Instance *_instance, uint8_t value){
if (_instance == &BlinkArduino_led_led_var) {
DigitalOutputArduino_handle_DigitalOutput_set_digital_output(&BlinkArduino_led_io_digital_output_var, value);
}
}
// Dispatch for messages TimerArduino::timer::timer_timeout
void dispatch_TimerArduino_send_timer_timer_timeout(struct TimerArduino_Instance *_instance){
if (_instance == &BlinkArduino_timer_var) {
Blink_handle_HW_timer_timeout(&BlinkArduino_app_var);
}
}
// Dispatch for messages Blink::HW::led_toggle
void dispatch_Blink_send_HW_led_toggle(struct Blink_Instance *_instance){
if (_instance == &BlinkArduino_app_var) {
LedUC_handle_Led_led_toggle(&BlinkArduino_led_led_var);
}
}
// Dispatch for messages Blink::HW::timer_start
void dispatch_Blink_send_HW_timer_start(struct Blink_Instance *_instance, int delay){
if (_instance == &BlinkArduino_app_var) {
TimerArduino_handle_timer_timer_start(&BlinkArduino_timer_var, delay);
}
}
// Dispatch for messages DigitalOutputArduino::DigitalIO::digital_write
void dispatch_DigitalOutputArduino_send_DigitalIO_digital_write(struct DigitalOutputArduino_Instance *_instance, uint8_t pin, uint8_t value){
if (_instance == &BlinkArduino_led_io_digital_output_var) {
ArduinoArduino_handle_DigitalIO_digital_write(&BlinkArduino_led_io_arduino_var, pin, value);
}
}
// Dispatch for messages DigitalOutputArduino::DigitalIO::pin_mode
void dispatch_DigitalOutputArduino_send_DigitalIO_pin_mode(struct DigitalOutputArduino_Instance *_instance, uint8_t pin, uint8_t mode){
if (_instance == &BlinkArduino_led_io_digital_output_var) {
ArduinoArduino_handle_DigitalIO_pin_mode(&BlinkArduino_led_io_arduino_var, pin, mode);
}
}

void processMessageQueue() {
if (fifo_empty()) return; // return if there is nothing to do

byte mbuf[4];
uint8_t mbufi = 0;

// Read the code of the next port/message in the queue
uint16_t code = fifo_dequeue() << 8;

code += fifo_dequeue();

// Switch to call the appropriate handler
switch(code) {
case 5:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_TimerArduino_send_timer_timer_timeout((struct TimerArduino_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
case 6:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_LedUC_send_DigitalOutput_set_digital_output((struct LedUC_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* value */ );
break;
case 3:
while (mbufi < 4) mbuf[mbufi++] = fifo_dequeue();
dispatch_DigitalOutputArduino_send_DigitalIO_digital_write((struct DigitalOutputArduino_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ ,
mbuf[3] /* value */ );
break;
case 4:
while (mbufi < 4) mbuf[mbufi++] = fifo_dequeue();
dispatch_DigitalOutputArduino_send_DigitalIO_pin_mode((struct DigitalOutputArduino_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ ,
mbuf[3] /* mode */ );
break;
case 1:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_Blink_send_HW_led_toggle((struct Blink_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
case 2:
while (mbufi < 4) mbuf[mbufi++] = fifo_dequeue();
dispatch_Blink_send_HW_timer_start((struct Blink_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
(mbuf[2]<<8) + mbuf[3] /* delay */ );
break;
}
}

void initialize_configuration_BlinkArduino() {
// Initialize connectors
register_LedUC_send_DigitalOutput_set_digital_output_listener(enqueue_LedUC_send_DigitalOutput_set_digital_output);
register_DigitalOutputArduino_send_DigitalIO_pin_mode_listener(enqueue_DigitalOutputArduino_send_DigitalIO_pin_mode);
register_DigitalOutputArduino_send_DigitalIO_digital_write_listener(enqueue_DigitalOutputArduino_send_DigitalIO_digital_write);
register_Blink_send_HW_led_toggle_listener(enqueue_Blink_send_HW_led_toggle);
register_Blink_send_HW_timer_start_listener(enqueue_Blink_send_HW_timer_start);
register_TimerArduino_send_timer_timer_timeout_listener(enqueue_TimerArduino_send_timer_timer_timeout);

// Init the ID, state variables and properties for instance BlinkArduino_led_io_arduino
BlinkArduino_led_io_arduino_var.id = add_instance( (void*) &BlinkArduino_led_io_arduino_var);
BlinkArduino_led_io_arduino_var.ArduinoArduino_ArduinoArduino_State = ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE;

// Init the ID, state variables and properties for instance BlinkArduino_led_led
BlinkArduino_led_led_var.id = add_instance( (void*) &BlinkArduino_led_led_var);
BlinkArduino_led_led_var.LedUC_LedImpl_State = LEDUC_LEDIMPL_LEDOFF_STATE;

// Init the ID, state variables and properties for instance BlinkArduino_timer
BlinkArduino_timer_var.id = add_instance( (void*) &BlinkArduino_timer_var);
BlinkArduino_timer_var.TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_IDLE_STATE;
BlinkArduino_timer_var.TimerArduino_SoftTimer_target__var = 0;

// Init the ID, state variables and properties for instance BlinkArduino_led_io_digital_output
BlinkArduino_led_io_digital_output_var.id = add_instance( (void*) &BlinkArduino_led_io_digital_output_var);
BlinkArduino_led_io_digital_output_var.DigitalOutputArduino_DigitalOutpuImpl_State = DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_RUNNING_STATE;
BlinkArduino_led_io_digital_output_var.DigitalOutputArduino_pin__var = DIGITALPIN_PIN_13;

// Init the ID, state variables and properties for instance BlinkArduino_app
BlinkArduino_app_var.id = add_instance( (void*) &BlinkArduino_app_var);
BlinkArduino_app_var.Blink_BlinkImpl_State = BLINK_BLINKIMPL_BLINKING_STATE;

LedUC_LedImpl_OnEntry(LEDUC_LEDIMPL_STATE, &BlinkArduino_led_led_var);
TimerArduino_SoftTimer_OnEntry(TIMERARDUINO_SOFTTIMER_STATE, &BlinkArduino_timer_var);
Blink_BlinkImpl_OnEntry(BLINK_BLINKIMPL_STATE, &BlinkArduino_app_var);
DigitalOutputArduino_DigitalOutpuImpl_OnEntry(DIGITALOUTPUTARDUINO_DIGITALOUTPUIMPL_STATE, &BlinkArduino_led_io_digital_output_var);
ArduinoArduino_ArduinoArduino_OnEntry(ARDUINOARDUINO_ARDUINOARDUINO_STATE, &BlinkArduino_led_io_arduino_var);
}

/*****************************************************************************
 * Main for configuration : BlinkArduino
 *****************************************************************************/

void setup() {
initialize_configuration_BlinkArduino();

}

void loop() {
TimerArduino_handle_Polling_poll(&BlinkArduino_timer_var);

processMessageQueue();
}